{"ast":null,"code":"import { AbiEncodingLengthMismatchError, BytesSizeMismatchError, UnsupportedPackedAbiType } from '../../errors/abi.js';\nimport { InvalidAddressError } from '../../errors/address.js';\nimport { isAddress } from '../address/isAddress.js';\nimport { concat } from '../data/concat.js';\nimport { pad } from '../data/pad.js';\nimport { boolToHex, numberToHex, stringToHex } from '../encoding/toHex.js';\nimport { arrayRegex, bytesRegex, integerRegex } from '../regex.js';\nexport function encodePacked(types, values) {\n  if (types.length !== values.length) throw new AbiEncodingLengthMismatchError({\n    expectedLength: types.length,\n    givenLength: values.length\n  });\n  const data = [];\n  for (let i = 0; i < types.length; i++) {\n    const type = types[i];\n    const value = values[i];\n    data.push(encode(type, value));\n  }\n  return concat(data);\n}\nfunction encode(type, value, isArray = false) {\n  if (type === 'address') {\n    const address = value;\n    if (!isAddress(address)) throw new InvalidAddressError({\n      address\n    });\n    return pad(address.toLowerCase(), {\n      size: isArray ? 32 : null\n    });\n  }\n  if (type === 'string') return stringToHex(value);\n  if (type === 'bytes') return value;\n  if (type === 'bool') return pad(boolToHex(value), {\n    size: isArray ? 32 : 1\n  });\n  const intMatch = type.match(integerRegex);\n  if (intMatch) {\n    const [_type, baseType, bits = '256'] = intMatch;\n    const size = parseInt(bits) / 8;\n    return numberToHex(value, {\n      size: isArray ? 32 : size,\n      signed: baseType === 'int'\n    });\n  }\n  const bytesMatch = type.match(bytesRegex);\n  if (bytesMatch) {\n    const [_type, size] = bytesMatch;\n    if (parseInt(size) !== (value.length - 2) / 2) throw new BytesSizeMismatchError({\n      expectedSize: parseInt(size),\n      givenSize: (value.length - 2) / 2\n    });\n    return pad(value, {\n      dir: 'right',\n      size: isArray ? 32 : null\n    });\n  }\n  const arrayMatch = type.match(arrayRegex);\n  if (arrayMatch && Array.isArray(value)) {\n    const [_type, childType] = arrayMatch;\n    const data = [];\n    for (let i = 0; i < value.length; i++) {\n      data.push(encode(childType, value[i], true));\n    }\n    if (data.length === 0) return '0x';\n    return concat(data);\n  }\n  throw new UnsupportedPackedAbiType(type);\n}","map":{"version":3,"names":["AbiEncodingLengthMismatchError","BytesSizeMismatchError","UnsupportedPackedAbiType","InvalidAddressError","isAddress","concat","pad","boolToHex","numberToHex","stringToHex","arrayRegex","bytesRegex","integerRegex","encodePacked","types","values","length","expectedLength","givenLength","data","i","type","value","push","encode","isArray","address","toLowerCase","size","intMatch","match","_type","baseType","bits","parseInt","signed","bytesMatch","expectedSize","givenSize","dir","arrayMatch","Array","childType"],"sources":["C:\\Users\\irakl\\OneDrive\\Desktop\\wallet-connect\\node_modules\\viem\\src\\utils\\abi\\encodePacked.ts"],"sourcesContent":["import type {\n  AbiParameterToPrimitiveType,\n  AbiType,\n  Address,\n  Narrow,\n  SolidityAddress,\n  SolidityArrayWithoutTuple,\n  SolidityBool,\n  SolidityBytes,\n  SolidityInt,\n  SolidityString,\n} from 'abitype'\n\nimport {\n  AbiEncodingLengthMismatchError,\n  BytesSizeMismatchError,\n  UnsupportedPackedAbiType,\n} from '../../errors/abi.js'\nimport { InvalidAddressError } from '../../errors/address.js'\nimport type { Hex } from '../../types/misc.js'\nimport { isAddress } from '../address/isAddress.js'\nimport { concat } from '../data/concat.js'\nimport { pad } from '../data/pad.js'\nimport { boolToHex, numberToHex, stringToHex } from '../encoding/toHex.js'\nimport { arrayRegex, bytesRegex, integerRegex } from '../regex.js'\n\ntype PackedAbiType =\n  | SolidityAddress\n  | SolidityBool\n  | SolidityBytes\n  | SolidityInt\n  | SolidityString\n  | SolidityArrayWithoutTuple\n\ntype EncodePackedValues<TPackedAbiTypes extends PackedAbiType[] | unknown[]> = {\n  [K in keyof TPackedAbiTypes]: TPackedAbiTypes[K] extends AbiType\n    ? AbiParameterToPrimitiveType<{ type: TPackedAbiTypes[K] }>\n    : unknown\n}\n\nexport function encodePacked<\n  TPackedAbiTypes extends PackedAbiType[] | unknown[],\n>(\n  types: Narrow<TPackedAbiTypes>,\n  values: EncodePackedValues<TPackedAbiTypes>,\n): Hex {\n  if (types.length !== values.length)\n    throw new AbiEncodingLengthMismatchError({\n      expectedLength: types.length as number,\n      givenLength: values.length as number,\n    })\n\n  const data: Hex[] = []\n  for (let i = 0; i < (types as unknown[]).length; i++) {\n    const type = types[i]\n    const value = values[i]\n    data.push(encode(type, value))\n  }\n  return concat(data)\n}\n\nfunction encode<TPackedAbiType extends PackedAbiType | unknown>(\n  type: TPackedAbiType,\n  value: EncodePackedValues<[TPackedAbiType]>[0],\n  isArray = false,\n): Hex {\n  if (type === 'address') {\n    const address = value as Address\n    if (!isAddress(address)) throw new InvalidAddressError({ address })\n    return pad(address.toLowerCase() as Hex, {\n      size: isArray ? 32 : null,\n    }) as Address\n  }\n  if (type === 'string') return stringToHex(value as string)\n  if (type === 'bytes') return value as Hex\n  if (type === 'bool')\n    return pad(boolToHex(value as boolean), { size: isArray ? 32 : 1 })\n\n  const intMatch = (type as string).match(integerRegex)\n  if (intMatch) {\n    const [_type, baseType, bits = '256'] = intMatch\n    const size = parseInt(bits) / 8\n    return numberToHex(value as number, {\n      size: isArray ? 32 : size,\n      signed: baseType === 'int',\n    })\n  }\n\n  const bytesMatch = (type as string).match(bytesRegex)\n  if (bytesMatch) {\n    const [_type, size] = bytesMatch\n    if (parseInt(size) !== ((value as Hex).length - 2) / 2)\n      throw new BytesSizeMismatchError({\n        expectedSize: parseInt(size),\n        givenSize: ((value as Hex).length - 2) / 2,\n      })\n    return pad(value as Hex, { dir: 'right', size: isArray ? 32 : null }) as Hex\n  }\n\n  const arrayMatch = (type as string).match(arrayRegex)\n  if (arrayMatch && Array.isArray(value)) {\n    const [_type, childType] = arrayMatch\n    const data: Hex[] = []\n    for (let i = 0; i < value.length; i++) {\n      data.push(encode(childType, value[i], true))\n    }\n    if (data.length === 0) return '0x'\n    return concat(data)\n  }\n\n  throw new UnsupportedPackedAbiType(type)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}