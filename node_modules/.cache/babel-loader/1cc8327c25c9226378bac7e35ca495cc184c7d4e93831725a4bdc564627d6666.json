{"ast":null,"code":"import { RELAYER_DEFAULT_PROTOCOL as de, RELAYER_EVENTS as b, EXPIRER_EVENTS as ge, Store as k, Core as ue } from \"@walletconnect/core\";\nimport { pino as me, getDefaultLoggerOptions as we, generateChildLogger as ye, getLoggerContext as Se } from \"@walletconnect/logger\";\nimport { IEngine as Ie, ISignClient as Ee } from \"@walletconnect/types\";\nimport { TYPE_1 as _e, createDelayedPromise as x, engineEvent as p, getInternalError as c, calcExpiry as _, isValidObject as Q, getRequiredNamespacesFromNamespaces as Re, getSdkError as R, handleDeeplinkRedirect as Ne, isSessionCompatible as qe, isBrowser as fe, hashMessage as z, isExpired as v, isValidParams as S, isUndefined as D, isValidRelays as ve, isValidRequiredNamespaces as Pe, isValidNamespaces as j, isConformingNamespaces as W, isValidString as C, isValidErrorReason as Oe, isValidRelay as Ve, isValidController as Te, isValidNamespacesChainId as Z, isValidRequest as xe, isValidNamespacesRequest as De, isValidRequestExpiry as Ce, isValidResponse as Ae, isValidEvent as Le, isValidNamespacesEvent as be, parseExpirerTarget as Ge, isValidId as $e, getAppMetadata as Me } from \"@walletconnect/utils\";\nimport Ue, { EventEmitter as Ke } from \"events\";\nimport { THIRTY_DAYS as ke, SEVEN_DAYS as ee, FIVE_MINUTES as m, ONE_DAY as P, THIRTY_SECONDS as se, ONE_SECOND as Qe, toMiliseconds as te } from \"@walletconnect/time\";\nimport { isJsonRpcResult as N, isJsonRpcError as q, getBigIntRpcId as ze, formatJsonRpcRequest as je, formatJsonRpcResult as Ye, formatJsonRpcError as Je, isJsonRpcRequest as Xe, isJsonRpcResponse as He } from \"@walletconnect/jsonrpc-utils\";\nconst Y = \"wc\",\n  J = 2,\n  X = \"client\",\n  G = `${Y}@${J}:${X}:`,\n  $ = {\n    name: X,\n    logger: \"error\",\n    controller: !1,\n    relayUrl: \"wss://relay.walletconnect.com\"\n  },\n  Fe = {\n    session_proposal: \"session_proposal\",\n    session_update: \"session_update\",\n    session_extend: \"session_extend\",\n    session_ping: \"session_ping\",\n    session_delete: \"session_delete\",\n    session_expire: \"session_expire\",\n    session_request: \"session_request\",\n    session_request_sent: \"session_request_sent\",\n    session_event: \"session_event\",\n    proposal_expire: \"proposal_expire\"\n  },\n  Be = {\n    database: \":memory:\"\n  },\n  H = \"WALLETCONNECT_DEEPLINK_CHOICE\",\n  We = {\n    created: \"history_created\",\n    updated: \"history_updated\",\n    deleted: \"history_deleted\",\n    sync: \"history_sync\"\n  },\n  Ze = \"history\",\n  es = \"0.3\",\n  ie = \"proposal\",\n  ss = ke,\n  re = \"Proposal expired\",\n  ne = \"session\",\n  A = ee,\n  oe = \"engine\",\n  O = {\n    wc_sessionPropose: {\n      req: {\n        ttl: m,\n        prompt: !0,\n        tag: 1100\n      },\n      res: {\n        ttl: m,\n        prompt: !1,\n        tag: 1101\n      }\n    },\n    wc_sessionSettle: {\n      req: {\n        ttl: m,\n        prompt: !1,\n        tag: 1102\n      },\n      res: {\n        ttl: m,\n        prompt: !1,\n        tag: 1103\n      }\n    },\n    wc_sessionUpdate: {\n      req: {\n        ttl: P,\n        prompt: !1,\n        tag: 1104\n      },\n      res: {\n        ttl: P,\n        prompt: !1,\n        tag: 1105\n      }\n    },\n    wc_sessionExtend: {\n      req: {\n        ttl: P,\n        prompt: !1,\n        tag: 1106\n      },\n      res: {\n        ttl: P,\n        prompt: !1,\n        tag: 1107\n      }\n    },\n    wc_sessionRequest: {\n      req: {\n        ttl: m,\n        prompt: !0,\n        tag: 1108\n      },\n      res: {\n        ttl: m,\n        prompt: !1,\n        tag: 1109\n      }\n    },\n    wc_sessionEvent: {\n      req: {\n        ttl: m,\n        prompt: !0,\n        tag: 1110\n      },\n      res: {\n        ttl: m,\n        prompt: !1,\n        tag: 1111\n      }\n    },\n    wc_sessionDelete: {\n      req: {\n        ttl: P,\n        prompt: !1,\n        tag: 1112\n      },\n      res: {\n        ttl: P,\n        prompt: !1,\n        tag: 1113\n      }\n    },\n    wc_sessionPing: {\n      req: {\n        ttl: se,\n        prompt: !1,\n        tag: 1114\n      },\n      res: {\n        ttl: se,\n        prompt: !1,\n        tag: 1115\n      }\n    }\n  },\n  M = {\n    min: m,\n    max: ee\n  },\n  V = {\n    idle: \"idle\",\n    active: \"active\"\n  },\n  ae = \"request\",\n  ce = [\"wc_sessionPropose\", \"wc_sessionRequest\", \"wc_authRequest\"];\nvar ts = Object.defineProperty,\n  is = Object.defineProperties,\n  rs = Object.getOwnPropertyDescriptors,\n  le = Object.getOwnPropertySymbols,\n  ns = Object.prototype.hasOwnProperty,\n  os = Object.prototype.propertyIsEnumerable,\n  pe = (d, r, e) => r in d ? ts(d, r, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : d[r] = e,\n  w = (d, r) => {\n    for (var e in r || (r = {})) ns.call(r, e) && pe(d, e, r[e]);\n    if (le) for (var e of le(r)) os.call(r, e) && pe(d, e, r[e]);\n    return d;\n  },\n  F = (d, r) => is(d, rs(r));\nclass as extends Ie {\n  constructor(r) {\n    super(r), this.name = oe, this.events = new Ue(), this.initialized = !1, this.ignoredPayloadTypes = [_e], this.requestQueue = {\n      state: V.idle,\n      requests: []\n    }, this.requestQueueDelay = Qe, this.init = async () => {\n      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.client.core.pairing.register({\n        methods: Object.keys(O)\n      }), this.initialized = !0, setTimeout(() => {\n        this.requestQueue.requests = this.getPendingSessionRequests(), this.processRequestQueue();\n      }, te(this.requestQueueDelay)));\n    }, this.connect = async e => {\n      this.isInitialized();\n      const s = F(w({}, e), {\n        requiredNamespaces: e.requiredNamespaces || {},\n        optionalNamespaces: e.optionalNamespaces || {}\n      });\n      await this.isValidConnect(s);\n      const {\n        pairingTopic: t,\n        requiredNamespaces: i,\n        optionalNamespaces: n,\n        sessionProperties: o,\n        relays: a\n      } = s;\n      let l = t,\n        h,\n        I = !1;\n      if (l && (I = this.client.core.pairing.pairings.get(l).active), !l || !I) {\n        const {\n          topic: f,\n          uri: y\n        } = await this.client.core.pairing.create();\n        l = f, h = y;\n      }\n      const g = await this.client.core.crypto.generateKeyPair(),\n        E = w({\n          requiredNamespaces: i,\n          optionalNamespaces: n,\n          relays: a ?? [{\n            protocol: de\n          }],\n          proposer: {\n            publicKey: g,\n            metadata: this.client.metadata\n          }\n        }, o && {\n          sessionProperties: o\n        }),\n        {\n          reject: u,\n          resolve: T,\n          done: K\n        } = x(m, re);\n      if (this.events.once(p(\"session_connect\"), async ({\n        error: f,\n        session: y\n      }) => {\n        if (f) u(f);else if (y) {\n          y.self.publicKey = g;\n          const B = F(w({}, y), {\n            requiredNamespaces: y.requiredNamespaces,\n            optionalNamespaces: y.optionalNamespaces\n          });\n          await this.client.session.set(y.topic, B), await this.setExpiry(y.topic, y.expiry), l && (await this.client.core.pairing.updateMetadata({\n            topic: l,\n            metadata: y.peer.metadata\n          })), T(B);\n        }\n      }), !l) {\n        const {\n          message: f\n        } = c(\"NO_MATCHING_KEY\", `connect() pairing topic: ${l}`);\n        throw new Error(f);\n      }\n      const L = await this.sendRequest(l, \"wc_sessionPropose\", E),\n        he = _(m);\n      return await this.setProposal(L, w({\n        id: L,\n        expiry: he\n      }, E)), {\n        uri: h,\n        approval: K\n      };\n    }, this.pair = async e => (this.isInitialized(), await this.client.core.pairing.pair(e)), this.approve = async e => {\n      this.isInitialized(), await this.isValidApprove(e);\n      const {\n          id: s,\n          relayProtocol: t,\n          namespaces: i,\n          sessionProperties: n\n        } = e,\n        o = this.client.proposal.get(s);\n      let {\n        pairingTopic: a,\n        proposer: l,\n        requiredNamespaces: h,\n        optionalNamespaces: I\n      } = o;\n      a = a || \"\", Q(h) || (h = Re(i, \"approve()\"));\n      const g = await this.client.core.crypto.generateKeyPair(),\n        E = l.publicKey,\n        u = await this.client.core.crypto.generateSharedKey(g, E);\n      a && s && (await this.client.core.pairing.updateMetadata({\n        topic: a,\n        metadata: l.metadata\n      }), await this.sendResult(s, a, {\n        relay: {\n          protocol: t ?? \"irn\"\n        },\n        responderPublicKey: g\n      }), await this.client.proposal.delete(s, R(\"USER_DISCONNECTED\")), await this.client.core.pairing.activate({\n        topic: a\n      }));\n      const T = w({\n        relay: {\n          protocol: t ?? \"irn\"\n        },\n        namespaces: i,\n        requiredNamespaces: h,\n        optionalNamespaces: I,\n        pairingTopic: a,\n        controller: {\n          publicKey: g,\n          metadata: this.client.metadata\n        },\n        expiry: _(A)\n      }, n && {\n        sessionProperties: n\n      });\n      await this.client.core.relayer.subscribe(u), await this.sendRequest(u, \"wc_sessionSettle\", T);\n      const K = F(w({}, T), {\n        topic: u,\n        pairingTopic: a,\n        acknowledged: !1,\n        self: T.controller,\n        peer: {\n          publicKey: l.publicKey,\n          metadata: l.metadata\n        },\n        controller: g\n      });\n      return await this.client.session.set(u, K), await this.setExpiry(u, _(A)), {\n        topic: u,\n        acknowledged: () => new Promise(L => setTimeout(() => L(this.client.session.get(u)), 500))\n      };\n    }, this.reject = async e => {\n      this.isInitialized(), await this.isValidReject(e);\n      const {\n          id: s,\n          reason: t\n        } = e,\n        {\n          pairingTopic: i\n        } = this.client.proposal.get(s);\n      i && (await this.sendError(s, i, t), await this.client.proposal.delete(s, R(\"USER_DISCONNECTED\")));\n    }, this.update = async e => {\n      this.isInitialized(), await this.isValidUpdate(e);\n      const {\n          topic: s,\n          namespaces: t\n        } = e,\n        i = await this.sendRequest(s, \"wc_sessionUpdate\", {\n          namespaces: t\n        }),\n        {\n          done: n,\n          resolve: o,\n          reject: a\n        } = x();\n      return this.events.once(p(\"session_update\", i), ({\n        error: l\n      }) => {\n        l ? a(l) : o();\n      }), await this.client.session.update(s, {\n        namespaces: t\n      }), {\n        acknowledged: n\n      };\n    }, this.extend = async e => {\n      this.isInitialized(), await this.isValidExtend(e);\n      const {\n          topic: s\n        } = e,\n        t = await this.sendRequest(s, \"wc_sessionExtend\", {}),\n        {\n          done: i,\n          resolve: n,\n          reject: o\n        } = x();\n      return this.events.once(p(\"session_extend\", t), ({\n        error: a\n      }) => {\n        a ? o(a) : n();\n      }), await this.setExpiry(s, _(A)), {\n        acknowledged: i\n      };\n    }, this.request = async e => {\n      this.isInitialized(), await this.isValidRequest(e);\n      const {\n          chainId: s,\n          request: t,\n          topic: i,\n          expiry: n\n        } = e,\n        o = await this.sendRequest(i, \"wc_sessionRequest\", {\n          request: t,\n          chainId: s\n        }, n),\n        {\n          done: a,\n          resolve: l,\n          reject: h\n        } = x(n);\n      this.events.once(p(\"session_request\", o), ({\n        error: g,\n        result: E\n      }) => {\n        g ? h(g) : l(E);\n      }), this.client.events.emit(\"session_request_sent\", {\n        topic: i,\n        request: t,\n        chainId: s,\n        id: o\n      });\n      const I = await this.client.core.storage.getItem(H);\n      return Ne({\n        id: o,\n        topic: i,\n        wcDeepLink: I\n      }), await a();\n    }, this.respond = async e => {\n      this.isInitialized(), await this.isValidRespond(e);\n      const {\n          topic: s,\n          response: t\n        } = e,\n        {\n          id: i\n        } = t;\n      N(t) ? await this.sendResult(i, s, t.result) : q(t) && (await this.sendError(i, s, t.error)), this.cleanupAfterResponse(e);\n    }, this.ping = async e => {\n      this.isInitialized(), await this.isValidPing(e);\n      const {\n        topic: s\n      } = e;\n      if (this.client.session.keys.includes(s)) {\n        const t = await this.sendRequest(s, \"wc_sessionPing\", {}),\n          {\n            done: i,\n            resolve: n,\n            reject: o\n          } = x();\n        this.events.once(p(\"session_ping\", t), ({\n          error: a\n        }) => {\n          a ? o(a) : n();\n        }), await i();\n      } else this.client.core.pairing.pairings.keys.includes(s) && (await this.client.core.pairing.ping({\n        topic: s\n      }));\n    }, this.emit = async e => {\n      this.isInitialized(), await this.isValidEmit(e);\n      const {\n        topic: s,\n        event: t,\n        chainId: i\n      } = e;\n      await this.sendRequest(s, \"wc_sessionEvent\", {\n        event: t,\n        chainId: i\n      });\n    }, this.disconnect = async e => {\n      this.isInitialized(), await this.isValidDisconnect(e);\n      const {\n        topic: s\n      } = e;\n      if (this.client.session.keys.includes(s)) {\n        const t = ze().toString();\n        let i;\n        const n = o => {\n          o?.id.toString() === t && (this.client.core.relayer.events.removeListener(b.message_ack, n), i());\n        };\n        await Promise.all([new Promise(o => {\n          i = o, this.client.core.relayer.on(b.message_ack, n);\n        }), this.sendRequest(s, \"wc_sessionDelete\", R(\"USER_DISCONNECTED\"), void 0, t)]), await this.deleteSession(s);\n      } else await this.client.core.pairing.disconnect({\n        topic: s\n      });\n    }, this.find = e => (this.isInitialized(), this.client.session.getAll().filter(s => qe(s, e))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.cleanupDuplicatePairings = async e => {\n      if (e.pairingTopic) try {\n        const s = this.client.core.pairing.pairings.get(e.pairingTopic),\n          t = this.client.core.pairing.pairings.getAll().filter(i => {\n            var n, o;\n            return ((n = i.peerMetadata) == null ? void 0 : n.url) && ((o = i.peerMetadata) == null ? void 0 : o.url) === e.peer.metadata.url && i.topic && i.topic !== s.topic;\n          });\n        if (t.length === 0) return;\n        this.client.logger.info(`Cleaning up ${t.length} duplicate pairing(s)`), await Promise.all(t.map(i => this.client.core.pairing.disconnect({\n          topic: i.topic\n        }))), this.client.logger.info(\"Duplicate pairings clean up finished\");\n      } catch (s) {\n        this.client.logger.error(s);\n      }\n    }, this.deleteSession = async (e, s) => {\n      const {\n        self: t\n      } = this.client.session.get(e);\n      await this.client.core.relayer.unsubscribe(e), this.client.session.delete(e, R(\"USER_DISCONNECTED\")), this.client.core.crypto.keychain.has(t.publicKey) && (await this.client.core.crypto.deleteKeyPair(t.publicKey)), this.client.core.crypto.keychain.has(e) && (await this.client.core.crypto.deleteSymKey(e)), s || this.client.core.expirer.del(e), this.client.core.storage.removeItem(H).catch(i => this.client.logger.warn(i));\n    }, this.deleteProposal = async (e, s) => {\n      await Promise.all([this.client.proposal.delete(e, R(\"USER_DISCONNECTED\")), s ? Promise.resolve() : this.client.core.expirer.del(e)]);\n    }, this.deletePendingSessionRequest = async (e, s, t = !1) => {\n      await Promise.all([this.client.pendingRequest.delete(e, s), t ? Promise.resolve() : this.client.core.expirer.del(e)]), this.requestQueue.requests = this.requestQueue.requests.filter(i => i.id !== e), t && (this.requestQueue.state = V.idle);\n    }, this.setExpiry = async (e, s) => {\n      this.client.session.keys.includes(e) && (await this.client.session.update(e, {\n        expiry: s\n      })), this.client.core.expirer.set(e, s);\n    }, this.setProposal = async (e, s) => {\n      await this.client.proposal.set(e, s), this.client.core.expirer.set(e, s.expiry);\n    }, this.setPendingSessionRequest = async e => {\n      const s = O.wc_sessionRequest.req.ttl,\n        {\n          id: t,\n          topic: i,\n          params: n\n        } = e;\n      await this.client.pendingRequest.set(t, {\n        id: t,\n        topic: i,\n        params: n\n      }), s && this.client.core.expirer.set(t, _(s));\n    }, this.sendRequest = async (e, s, t, i, n) => {\n      const o = je(s, t);\n      if (fe() && ce.includes(s)) {\n        const h = z(JSON.stringify(o));\n        await this.client.core.verify.register({\n          attestationId: h\n        });\n      }\n      const a = await this.client.core.crypto.encode(e, o),\n        l = O[s].req;\n      return i && (l.ttl = i), n && (l.id = n), this.client.core.history.set(e, o), this.client.core.relayer.publish(e, a, l), o.id;\n    }, this.sendResult = async (e, s, t) => {\n      const i = Ye(e, t),\n        n = await this.client.core.crypto.encode(s, i),\n        o = await this.client.core.history.get(s, e),\n        a = O[o.request.method].res;\n      this.client.core.relayer.publish(s, n, a), await this.client.core.history.resolve(i);\n    }, this.sendError = async (e, s, t) => {\n      const i = Je(e, t),\n        n = await this.client.core.crypto.encode(s, i),\n        o = await this.client.core.history.get(s, e),\n        a = O[o.request.method].res;\n      this.client.core.relayer.publish(s, n, a), await this.client.core.history.resolve(i);\n    }, this.cleanup = async () => {\n      const e = [],\n        s = [];\n      this.client.session.getAll().forEach(t => {\n        v(t.expiry) && e.push(t.topic);\n      }), this.client.proposal.getAll().forEach(t => {\n        v(t.expiry) && s.push(t.id);\n      }), await Promise.all([...e.map(t => this.deleteSession(t)), ...s.map(t => this.deleteProposal(t))]);\n    }, this.onRelayEventRequest = e => {\n      const {\n          topic: s,\n          payload: t\n        } = e,\n        i = t.method;\n      switch (i) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeRequest(s, t);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleRequest(s, t);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateRequest(s, t);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendRequest(s, t);\n        case \"wc_sessionPing\":\n          return this.onSessionPingRequest(s, t);\n        case \"wc_sessionDelete\":\n          return this.onSessionDeleteRequest(s, t);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequest(s, t);\n        case \"wc_sessionEvent\":\n          return this.onSessionEventRequest(s, t);\n        default:\n          return this.client.logger.info(`Unsupported request method ${i}`);\n      }\n    }, this.onRelayEventResponse = async e => {\n      const {\n          topic: s,\n          payload: t\n        } = e,\n        i = (await this.client.core.history.get(s, t.id)).request.method;\n      switch (i) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeResponse(s, t);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleResponse(s, t);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateResponse(s, t);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendResponse(s, t);\n        case \"wc_sessionPing\":\n          return this.onSessionPingResponse(s, t);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequestResponse(s, t);\n        default:\n          return this.client.logger.info(`Unsupported response method ${i}`);\n      }\n    }, this.onRelayEventUnknownPayload = e => {\n      const {\n          topic: s\n        } = e,\n        {\n          message: t\n        } = c(\"MISSING_OR_INVALID\", `Decoded payload on topic ${s} is not identifiable as a JSON-RPC request or a response.`);\n      throw new Error(t);\n    }, this.onSessionProposeRequest = async (e, s) => {\n      const {\n        params: t,\n        id: i\n      } = s;\n      try {\n        this.isValidConnect(w({}, s.params));\n        const n = _(m),\n          o = w({\n            id: i,\n            pairingTopic: e,\n            expiry: n\n          }, t);\n        await this.setProposal(i, o);\n        const a = z(JSON.stringify(s)),\n          l = await this.getVerifyContext(a, o.proposer.metadata);\n        this.client.events.emit(\"session_proposal\", {\n          id: i,\n          params: o,\n          verifyContext: l\n        });\n      } catch (n) {\n        await this.sendError(i, e, n), this.client.logger.error(n);\n      }\n    }, this.onSessionProposeResponse = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      if (N(s)) {\n        const {\n          result: i\n        } = s;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          result: i\n        });\n        const n = this.client.proposal.get(t);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          proposal: n\n        });\n        const o = n.proposer.publicKey;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          selfPublicKey: o\n        });\n        const a = i.responderPublicKey;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          peerPublicKey: a\n        });\n        const l = await this.client.core.crypto.generateSharedKey(o, a);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          sessionTopic: l\n        });\n        const h = await this.client.core.relayer.subscribe(l);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          subscriptionId: h\n        }), await this.client.core.pairing.activate({\n          topic: e\n        });\n      } else q(s) && (await this.client.proposal.delete(t, R(\"USER_DISCONNECTED\")), this.events.emit(p(\"session_connect\"), {\n        error: s.error\n      }));\n    }, this.onSessionSettleRequest = async (e, s) => {\n      const {\n        id: t,\n        params: i\n      } = s;\n      try {\n        this.isValidSessionSettleRequest(i);\n        const {\n            relay: n,\n            controller: o,\n            expiry: a,\n            namespaces: l,\n            requiredNamespaces: h,\n            optionalNamespaces: I,\n            sessionProperties: g,\n            pairingTopic: E\n          } = s.params,\n          u = w({\n            topic: e,\n            relay: n,\n            expiry: a,\n            namespaces: l,\n            acknowledged: !0,\n            pairingTopic: E,\n            requiredNamespaces: h,\n            optionalNamespaces: I,\n            controller: o.publicKey,\n            self: {\n              publicKey: \"\",\n              metadata: this.client.metadata\n            },\n            peer: {\n              publicKey: o.publicKey,\n              metadata: o.metadata\n            }\n          }, g && {\n            sessionProperties: g\n          });\n        await this.sendResult(s.id, e, !0), this.events.emit(p(\"session_connect\"), {\n          session: u\n        }), this.cleanupDuplicatePairings(u);\n      } catch (n) {\n        await this.sendError(t, e, n), this.client.logger.error(n);\n      }\n    }, this.onSessionSettleResponse = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      N(s) ? (await this.client.session.update(e, {\n        acknowledged: !0\n      }), this.events.emit(p(\"session_approve\", t), {})) : q(s) && (await this.client.session.delete(e, R(\"USER_DISCONNECTED\")), this.events.emit(p(\"session_approve\", t), {\n        error: s.error\n      }));\n    }, this.onSessionUpdateRequest = async (e, s) => {\n      const {\n        params: t,\n        id: i\n      } = s;\n      try {\n        this.isValidUpdate(w({\n          topic: e\n        }, t)), await this.client.session.update(e, {\n          namespaces: t.namespaces\n        }), await this.sendResult(i, e, !0), this.client.events.emit(\"session_update\", {\n          id: i,\n          topic: e,\n          params: t\n        });\n      } catch (n) {\n        await this.sendError(i, e, n), this.client.logger.error(n);\n      }\n    }, this.onSessionUpdateResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      N(s) ? this.events.emit(p(\"session_update\", t), {}) : q(s) && this.events.emit(p(\"session_update\", t), {\n        error: s.error\n      });\n    }, this.onSessionExtendRequest = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      try {\n        this.isValidExtend({\n          topic: e\n        }), await this.setExpiry(e, _(A)), await this.sendResult(t, e, !0), this.client.events.emit(\"session_extend\", {\n          id: t,\n          topic: e\n        });\n      } catch (i) {\n        await this.sendError(t, e, i), this.client.logger.error(i);\n      }\n    }, this.onSessionExtendResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      N(s) ? this.events.emit(p(\"session_extend\", t), {}) : q(s) && this.events.emit(p(\"session_extend\", t), {\n        error: s.error\n      });\n    }, this.onSessionPingRequest = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      try {\n        this.isValidPing({\n          topic: e\n        }), await this.sendResult(t, e, !0), this.client.events.emit(\"session_ping\", {\n          id: t,\n          topic: e\n        });\n      } catch (i) {\n        await this.sendError(t, e, i), this.client.logger.error(i);\n      }\n    }, this.onSessionPingResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      setTimeout(() => {\n        N(s) ? this.events.emit(p(\"session_ping\", t), {}) : q(s) && this.events.emit(p(\"session_ping\", t), {\n          error: s.error\n        });\n      }, 500);\n    }, this.onSessionDeleteRequest = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      try {\n        this.isValidDisconnect({\n          topic: e,\n          reason: s.params\n        }), await Promise.all([new Promise(i => {\n          this.client.core.relayer.once(b.publish, async () => {\n            i(await this.deleteSession(e));\n          });\n        }), this.sendResult(t, e, !0)]), this.client.events.emit(\"session_delete\", {\n          id: t,\n          topic: e\n        });\n      } catch (i) {\n        this.client.logger.error(i);\n      }\n    }, this.onSessionRequest = async (e, s) => {\n      const {\n        id: t,\n        params: i\n      } = s;\n      try {\n        this.isValidRequest(w({\n          topic: e\n        }, i)), await this.setPendingSessionRequest({\n          id: t,\n          topic: e,\n          params: i\n        }), this.addRequestToQueue({\n          id: t,\n          topic: e,\n          params: i\n        }), await this.processRequestQueue();\n      } catch (n) {\n        await this.sendError(t, e, n), this.client.logger.error(n);\n      }\n    }, this.onSessionRequestResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      N(s) ? this.events.emit(p(\"session_request\", t), {\n        result: s.result\n      }) : q(s) && this.events.emit(p(\"session_request\", t), {\n        error: s.error\n      });\n    }, this.onSessionEventRequest = async (e, s) => {\n      const {\n        id: t,\n        params: i\n      } = s;\n      try {\n        this.isValidEmit(w({\n          topic: e\n        }, i)), this.client.events.emit(\"session_event\", {\n          id: t,\n          topic: e,\n          params: i\n        });\n      } catch (n) {\n        await this.sendError(t, e, n), this.client.logger.error(n);\n      }\n    }, this.addRequestToQueue = e => {\n      this.requestQueue.requests.push(e);\n    }, this.cleanupAfterResponse = e => {\n      this.deletePendingSessionRequest(e.response.id, {\n        message: \"fulfilled\",\n        code: 0\n      }), setTimeout(() => {\n        this.requestQueue.state = V.idle, this.processRequestQueue();\n      }, te(this.requestQueueDelay));\n    }, this.processRequestQueue = async () => {\n      if (this.requestQueue.state === V.active) {\n        this.client.logger.info(\"session request queue is already active.\");\n        return;\n      }\n      const e = this.requestQueue.requests[0];\n      if (!e) {\n        this.client.logger.info(\"session request queue is empty.\");\n        return;\n      }\n      try {\n        const {\n            id: s,\n            topic: t,\n            params: i\n          } = e,\n          n = z(JSON.stringify({\n            id: s,\n            params: i\n          })),\n          o = this.client.session.get(t),\n          a = await this.getVerifyContext(n, o.peer.metadata);\n        this.requestQueue.state = V.active, this.client.events.emit(\"session_request\", {\n          id: s,\n          topic: t,\n          params: i,\n          verifyContext: a\n        });\n      } catch (s) {\n        this.client.logger.error(s);\n      }\n    }, this.isValidConnect = async e => {\n      if (!S(e)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `connect() params: ${JSON.stringify(e)}`);\n        throw new Error(a);\n      }\n      const {\n        pairingTopic: s,\n        requiredNamespaces: t,\n        optionalNamespaces: i,\n        sessionProperties: n,\n        relays: o\n      } = e;\n      if (D(s) || (await this.isValidPairingTopic(s)), !ve(o, !0)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `connect() relays: ${o}`);\n        throw new Error(a);\n      }\n      !D(t) && Q(t) !== 0 && this.validateNamespaces(t, \"requiredNamespaces\"), !D(i) && Q(i) !== 0 && this.validateNamespaces(i, \"optionalNamespaces\"), D(n) || this.validateSessionProps(n, \"sessionProperties\");\n    }, this.validateNamespaces = (e, s) => {\n      const t = Pe(e, \"connect()\", s);\n      if (t) throw new Error(t.message);\n    }, this.isValidApprove = async e => {\n      if (!S(e)) throw new Error(c(\"MISSING_OR_INVALID\", `approve() params: ${e}`).message);\n      const {\n        id: s,\n        namespaces: t,\n        relayProtocol: i,\n        sessionProperties: n\n      } = e;\n      await this.isValidProposalId(s);\n      const o = this.client.proposal.get(s),\n        a = j(t, \"approve()\");\n      if (a) throw new Error(a.message);\n      const l = W(o.requiredNamespaces, t, \"approve()\");\n      if (l) throw new Error(l.message);\n      if (!C(i, !0)) {\n        const {\n          message: h\n        } = c(\"MISSING_OR_INVALID\", `approve() relayProtocol: ${i}`);\n        throw new Error(h);\n      }\n      D(n) || this.validateSessionProps(n, \"sessionProperties\");\n    }, this.isValidReject = async e => {\n      if (!S(e)) {\n        const {\n          message: i\n        } = c(\"MISSING_OR_INVALID\", `reject() params: ${e}`);\n        throw new Error(i);\n      }\n      const {\n        id: s,\n        reason: t\n      } = e;\n      if (await this.isValidProposalId(s), !Oe(t)) {\n        const {\n          message: i\n        } = c(\"MISSING_OR_INVALID\", `reject() reason: ${JSON.stringify(t)}`);\n        throw new Error(i);\n      }\n    }, this.isValidSessionSettleRequest = e => {\n      if (!S(e)) {\n        const {\n          message: l\n        } = c(\"MISSING_OR_INVALID\", `onSessionSettleRequest() params: ${e}`);\n        throw new Error(l);\n      }\n      const {\n        relay: s,\n        controller: t,\n        namespaces: i,\n        expiry: n\n      } = e;\n      if (!Ve(s)) {\n        const {\n          message: l\n        } = c(\"MISSING_OR_INVALID\", \"onSessionSettleRequest() relay protocol should be a string\");\n        throw new Error(l);\n      }\n      const o = Te(t, \"onSessionSettleRequest()\");\n      if (o) throw new Error(o.message);\n      const a = j(i, \"onSessionSettleRequest()\");\n      if (a) throw new Error(a.message);\n      if (v(n)) {\n        const {\n          message: l\n        } = c(\"EXPIRED\", \"onSessionSettleRequest()\");\n        throw new Error(l);\n      }\n    }, this.isValidUpdate = async e => {\n      if (!S(e)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `update() params: ${e}`);\n        throw new Error(a);\n      }\n      const {\n        topic: s,\n        namespaces: t\n      } = e;\n      await this.isValidSessionTopic(s);\n      const i = this.client.session.get(s),\n        n = j(t, \"update()\");\n      if (n) throw new Error(n.message);\n      const o = W(i.requiredNamespaces, t, \"update()\");\n      if (o) throw new Error(o.message);\n    }, this.isValidExtend = async e => {\n      if (!S(e)) {\n        const {\n          message: t\n        } = c(\"MISSING_OR_INVALID\", `extend() params: ${e}`);\n        throw new Error(t);\n      }\n      const {\n        topic: s\n      } = e;\n      await this.isValidSessionTopic(s);\n    }, this.isValidRequest = async e => {\n      if (!S(e)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `request() params: ${e}`);\n        throw new Error(a);\n      }\n      const {\n        topic: s,\n        request: t,\n        chainId: i,\n        expiry: n\n      } = e;\n      await this.isValidSessionTopic(s);\n      const {\n        namespaces: o\n      } = this.client.session.get(s);\n      if (!Z(o, i)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `request() chainId: ${i}`);\n        throw new Error(a);\n      }\n      if (!xe(t)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `request() ${JSON.stringify(t)}`);\n        throw new Error(a);\n      }\n      if (!De(o, i, t.method)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `request() method: ${t.method}`);\n        throw new Error(a);\n      }\n      if (n && !Ce(n, M)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `request() expiry: ${n}. Expiry must be a number (in seconds) between ${M.min} and ${M.max}`);\n        throw new Error(a);\n      }\n    }, this.isValidRespond = async e => {\n      if (!S(e)) {\n        const {\n          message: i\n        } = c(\"MISSING_OR_INVALID\", `respond() params: ${e}`);\n        throw new Error(i);\n      }\n      const {\n        topic: s,\n        response: t\n      } = e;\n      if (await this.isValidSessionTopic(s), !Ae(t)) {\n        const {\n          message: i\n        } = c(\"MISSING_OR_INVALID\", `respond() response: ${JSON.stringify(t)}`);\n        throw new Error(i);\n      }\n    }, this.isValidPing = async e => {\n      if (!S(e)) {\n        const {\n          message: t\n        } = c(\"MISSING_OR_INVALID\", `ping() params: ${e}`);\n        throw new Error(t);\n      }\n      const {\n        topic: s\n      } = e;\n      await this.isValidSessionOrPairingTopic(s);\n    }, this.isValidEmit = async e => {\n      if (!S(e)) {\n        const {\n          message: o\n        } = c(\"MISSING_OR_INVALID\", `emit() params: ${e}`);\n        throw new Error(o);\n      }\n      const {\n        topic: s,\n        event: t,\n        chainId: i\n      } = e;\n      await this.isValidSessionTopic(s);\n      const {\n        namespaces: n\n      } = this.client.session.get(s);\n      if (!Z(n, i)) {\n        const {\n          message: o\n        } = c(\"MISSING_OR_INVALID\", `emit() chainId: ${i}`);\n        throw new Error(o);\n      }\n      if (!Le(t)) {\n        const {\n          message: o\n        } = c(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(t)}`);\n        throw new Error(o);\n      }\n      if (!be(n, i, t.name)) {\n        const {\n          message: o\n        } = c(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(t)}`);\n        throw new Error(o);\n      }\n    }, this.isValidDisconnect = async e => {\n      if (!S(e)) {\n        const {\n          message: t\n        } = c(\"MISSING_OR_INVALID\", `disconnect() params: ${e}`);\n        throw new Error(t);\n      }\n      const {\n        topic: s\n      } = e;\n      await this.isValidSessionOrPairingTopic(s);\n    }, this.getVerifyContext = async (e, s) => {\n      const t = {\n        verified: {\n          verifyUrl: s.verifyUrl || \"\",\n          validation: \"UNKNOWN\",\n          origin: s.url || \"\"\n        }\n      };\n      try {\n        const i = await this.client.core.verify.resolve({\n          attestationId: e,\n          verifyUrl: s.verifyUrl\n        });\n        i && (t.verified.origin = i, t.verified.validation = i === s.url ? \"VALID\" : \"INVALID\");\n      } catch (i) {\n        this.client.logger.error(i);\n      }\n      return this.client.logger.info(`Verify context: ${JSON.stringify(t)}`), t;\n    }, this.validateSessionProps = (e, s) => {\n      Object.values(e).forEach(t => {\n        if (!C(t, !1)) {\n          const {\n            message: i\n          } = c(\"MISSING_OR_INVALID\", `${s} must be in Record<string, string> format. Received: ${JSON.stringify(t)}`);\n          throw new Error(i);\n        }\n      });\n    };\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: r\n      } = c(\"NOT_INITIALIZED\", this.name);\n      throw new Error(r);\n    }\n  }\n  registerRelayerEvents() {\n    this.client.core.relayer.on(b.message, async r => {\n      const {\n        topic: e,\n        message: s\n      } = r;\n      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s))) return;\n      const t = await this.client.core.crypto.decode(e, s);\n      try {\n        Xe(t) ? (this.client.core.history.set(e, t), this.onRelayEventRequest({\n          topic: e,\n          payload: t\n        })) : He(t) ? (await this.client.core.history.resolve(t), await this.onRelayEventResponse({\n          topic: e,\n          payload: t\n        }), this.client.core.history.delete(e, t.id)) : this.onRelayEventUnknownPayload({\n          topic: e,\n          payload: t\n        });\n      } catch (i) {\n        this.client.logger.error(i);\n      }\n    });\n  }\n  registerExpirerEvents() {\n    this.client.core.expirer.on(ge.expired, async r => {\n      const {\n        topic: e,\n        id: s\n      } = Ge(r.target);\n      if (s && this.client.pendingRequest.keys.includes(s)) return await this.deletePendingSessionRequest(s, c(\"EXPIRED\"), !0);\n      e ? this.client.session.keys.includes(e) && (await this.deleteSession(e, !0), this.client.events.emit(\"session_expire\", {\n        topic: e\n      })) : s && (await this.deleteProposal(s, !0), this.client.events.emit(\"proposal_expire\", {\n        id: s\n      }));\n    });\n  }\n  isValidPairingTopic(r) {\n    if (!C(r, !1)) {\n      const {\n        message: e\n      } = c(\"MISSING_OR_INVALID\", `pairing topic should be a string: ${r}`);\n      throw new Error(e);\n    }\n    if (!this.client.core.pairing.pairings.keys.includes(r)) {\n      const {\n        message: e\n      } = c(\"NO_MATCHING_KEY\", `pairing topic doesn't exist: ${r}`);\n      throw new Error(e);\n    }\n    if (v(this.client.core.pairing.pairings.get(r).expiry)) {\n      const {\n        message: e\n      } = c(\"EXPIRED\", `pairing topic: ${r}`);\n      throw new Error(e);\n    }\n  }\n  async isValidSessionTopic(r) {\n    if (!C(r, !1)) {\n      const {\n        message: e\n      } = c(\"MISSING_OR_INVALID\", `session topic should be a string: ${r}`);\n      throw new Error(e);\n    }\n    if (!this.client.session.keys.includes(r)) {\n      const {\n        message: e\n      } = c(\"NO_MATCHING_KEY\", `session topic doesn't exist: ${r}`);\n      throw new Error(e);\n    }\n    if (v(this.client.session.get(r).expiry)) {\n      await this.deleteSession(r);\n      const {\n        message: e\n      } = c(\"EXPIRED\", `session topic: ${r}`);\n      throw new Error(e);\n    }\n  }\n  async isValidSessionOrPairingTopic(r) {\n    if (this.client.session.keys.includes(r)) await this.isValidSessionTopic(r);else if (this.client.core.pairing.pairings.keys.includes(r)) this.isValidPairingTopic(r);else if (C(r, !1)) {\n      const {\n        message: e\n      } = c(\"NO_MATCHING_KEY\", `session or pairing topic doesn't exist: ${r}`);\n      throw new Error(e);\n    } else {\n      const {\n        message: e\n      } = c(\"MISSING_OR_INVALID\", `session or pairing topic should be a string: ${r}`);\n      throw new Error(e);\n    }\n  }\n  async isValidProposalId(r) {\n    if (!$e(r)) {\n      const {\n        message: e\n      } = c(\"MISSING_OR_INVALID\", `proposal id should be a number: ${r}`);\n      throw new Error(e);\n    }\n    if (!this.client.proposal.keys.includes(r)) {\n      const {\n        message: e\n      } = c(\"NO_MATCHING_KEY\", `proposal id doesn't exist: ${r}`);\n      throw new Error(e);\n    }\n    if (v(this.client.proposal.get(r).expiry)) {\n      await this.deleteProposal(r);\n      const {\n        message: e\n      } = c(\"EXPIRED\", `proposal id: ${r}`);\n      throw new Error(e);\n    }\n  }\n}\nclass cs extends k {\n  constructor(r, e) {\n    super(r, e, ie, G), this.core = r, this.logger = e;\n  }\n}\nclass ls extends k {\n  constructor(r, e) {\n    super(r, e, ne, G), this.core = r, this.logger = e;\n  }\n}\nclass ps extends k {\n  constructor(r, e) {\n    super(r, e, ae, G, s => s.id), this.core = r, this.logger = e;\n  }\n}\nclass U extends Ee {\n  constructor(r) {\n    super(r), this.protocol = Y, this.version = J, this.name = $.name, this.events = new Ke(), this.on = (s, t) => this.events.on(s, t), this.once = (s, t) => this.events.once(s, t), this.off = (s, t) => this.events.off(s, t), this.removeListener = (s, t) => this.events.removeListener(s, t), this.removeAllListeners = s => this.events.removeAllListeners(s), this.connect = async s => {\n      try {\n        return await this.engine.connect(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.pair = async s => {\n      try {\n        return await this.engine.pair(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.approve = async s => {\n      try {\n        return await this.engine.approve(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.reject = async s => {\n      try {\n        return await this.engine.reject(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.update = async s => {\n      try {\n        return await this.engine.update(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.extend = async s => {\n      try {\n        return await this.engine.extend(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.request = async s => {\n      try {\n        return await this.engine.request(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.respond = async s => {\n      try {\n        return await this.engine.respond(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.ping = async s => {\n      try {\n        return await this.engine.ping(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.emit = async s => {\n      try {\n        return await this.engine.emit(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.disconnect = async s => {\n      try {\n        return await this.engine.disconnect(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.find = s => {\n      try {\n        return this.engine.find(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.getPendingSessionRequests = () => {\n      try {\n        return this.engine.getPendingSessionRequests();\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.name = r?.name || $.name, this.metadata = r?.metadata || Me();\n    const e = typeof r?.logger < \"u\" && typeof r?.logger != \"string\" ? r.logger : me(we({\n      level: r?.logger || $.logger\n    }));\n    this.core = r?.core || new ue(r), this.logger = ye(e, this.name), this.session = new ls(this.core, this.logger), this.proposal = new cs(this.core, this.logger), this.pendingRequest = new ps(this.core, this.logger), this.engine = new as(this);\n  }\n  static async init(r) {\n    const e = new U(r);\n    return await e.initialize(), e;\n  }\n  get context() {\n    return Se(this.logger);\n  }\n  get pairing() {\n    return this.core.pairing.pairings;\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n    try {\n      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({\n        verifyUrl: this.metadata.verifyUrl\n      }), this.logger.info(\"SignClient Initialization Success\");\n    } catch (r) {\n      throw this.logger.info(\"SignClient Initialization Failure\"), this.logger.error(r.message), r;\n    }\n  }\n}\nconst hs = U;\nexport { oe as ENGINE_CONTEXT, O as ENGINE_RPC_OPTS, Ze as HISTORY_CONTEXT, We as HISTORY_EVENTS, es as HISTORY_STORAGE_VERSION, ce as METHODS_TO_VERIFY, ie as PROPOSAL_CONTEXT, ss as PROPOSAL_EXPIRY, re as PROPOSAL_EXPIRY_MESSAGE, ae as REQUEST_CONTEXT, V as REQUEST_QUEUE_STATES, ne as SESSION_CONTEXT, A as SESSION_EXPIRY, M as SESSION_REQUEST_EXPIRY_BOUNDARIES, X as SIGN_CLIENT_CONTEXT, $ as SIGN_CLIENT_DEFAULT, Fe as SIGN_CLIENT_EVENTS, Y as SIGN_CLIENT_PROTOCOL, Be as SIGN_CLIENT_STORAGE_OPTIONS, G as SIGN_CLIENT_STORAGE_PREFIX, J as SIGN_CLIENT_VERSION, hs as SignClient, H as WALLETCONNECT_DEEPLINK_CHOICE, U as default };","map":{"version":3,"names":[],"sources":["C:\\Users\\irakl\\OneDrive\\Desktop\\wallet-connect\\node_modules\\@walletconnect\\sign-client\\src\\constants\\client.ts","C:\\Users\\irakl\\OneDrive\\Desktop\\wallet-connect\\node_modules\\@walletconnect\\sign-client\\src\\constants\\history.ts","C:\\Users\\irakl\\OneDrive\\Desktop\\wallet-connect\\node_modules\\@walletconnect\\sign-client\\src\\constants\\proposal.ts","C:\\Users\\irakl\\OneDrive\\Desktop\\wallet-connect\\node_modules\\@walletconnect\\sign-client\\src\\constants\\session.ts","C:\\Users\\irakl\\OneDrive\\Desktop\\wallet-connect\\node_modules\\@walletconnect\\sign-client\\src\\constants\\engine.ts","C:\\Users\\irakl\\OneDrive\\Desktop\\wallet-connect\\node_modules\\@walletconnect\\sign-client\\src\\constants\\pendingRequest.ts","C:\\Users\\irakl\\OneDrive\\Desktop\\wallet-connect\\node_modules\\@walletconnect\\sign-client\\src\\constants\\verify.ts","C:\\Users\\irakl\\OneDrive\\Desktop\\wallet-connect\\node_modules\\@walletconnect\\sign-client\\src\\controllers\\engine.ts","C:\\Users\\irakl\\OneDrive\\Desktop\\wallet-connect\\node_modules\\@walletconnect\\sign-client\\src\\controllers\\proposal.ts","C:\\Users\\irakl\\OneDrive\\Desktop\\wallet-connect\\node_modules\\@walletconnect\\sign-client\\src\\controllers\\session.ts","C:\\Users\\irakl\\OneDrive\\Desktop\\wallet-connect\\node_modules\\@walletconnect\\sign-client\\src\\controllers\\pendingRequest.ts","C:\\Users\\irakl\\OneDrive\\Desktop\\wallet-connect\\node_modules\\@walletconnect\\sign-client\\src\\client.ts","C:\\Users\\irakl\\OneDrive\\Desktop\\wallet-connect\\node_modules\\@walletconnect\\sign-client\\src\\index.ts"],"sourcesContent":["import { SignClientTypes } from \"@walletconnect/types\";\n\nexport const SIGN_CLIENT_PROTOCOL = \"wc\";\nexport const SIGN_CLIENT_VERSION = 2;\nexport const SIGN_CLIENT_CONTEXT = \"client\";\n\nexport const SIGN_CLIENT_STORAGE_PREFIX = `${SIGN_CLIENT_PROTOCOL}@${SIGN_CLIENT_VERSION}:${SIGN_CLIENT_CONTEXT}:`;\n\nexport const SIGN_CLIENT_DEFAULT = {\n  name: SIGN_CLIENT_CONTEXT,\n  logger: \"error\",\n  controller: false,\n  relayUrl: \"wss://relay.walletconnect.com\",\n};\n\nexport const SIGN_CLIENT_EVENTS: Record<SignClientTypes.Event, SignClientTypes.Event> = {\n  session_proposal: \"session_proposal\",\n  session_update: \"session_update\",\n  session_extend: \"session_extend\",\n  session_ping: \"session_ping\",\n  session_delete: \"session_delete\",\n  session_expire: \"session_expire\",\n  session_request: \"session_request\",\n  session_request_sent: \"session_request_sent\",\n  session_event: \"session_event\",\n  proposal_expire: \"proposal_expire\",\n};\n\nexport const SIGN_CLIENT_STORAGE_OPTIONS = {\n  database: \":memory:\",\n};\n\nexport const WALLETCONNECT_DEEPLINK_CHOICE = \"WALLETCONNECT_DEEPLINK_CHOICE\";\n","export const HISTORY_EVENTS = {\n  created: \"history_created\",\n  updated: \"history_updated\",\n  deleted: \"history_deleted\",\n  sync: \"history_sync\",\n};\n\nexport const HISTORY_CONTEXT = \"history\";\n\nexport const HISTORY_STORAGE_VERSION = \"0.3\";\n","import { THIRTY_DAYS } from \"@walletconnect/time\";\n\nexport const PROPOSAL_CONTEXT = \"proposal\";\n\nexport const PROPOSAL_EXPIRY = THIRTY_DAYS;\n\nexport const PROPOSAL_EXPIRY_MESSAGE = \"Proposal expired\";\n","import { SEVEN_DAYS } from \"@walletconnect/time\";\n\nexport const SESSION_CONTEXT = \"session\";\n\nexport const SESSION_EXPIRY = SEVEN_DAYS;\n","import { FIVE_MINUTES, ONE_DAY, SEVEN_DAYS, THIRTY_SECONDS } from \"@walletconnect/time\";\nimport { EngineTypes } from \"@walletconnect/types\";\n\nexport const ENGINE_CONTEXT = \"engine\";\n\nexport const ENGINE_RPC_OPTS: EngineTypes.RpcOptsMap = {\n  wc_sessionPropose: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1100,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1101,\n    },\n  },\n  wc_sessionSettle: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1102,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1103,\n    },\n  },\n  wc_sessionUpdate: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1104,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1105,\n    },\n  },\n  wc_sessionExtend: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1106,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1107,\n    },\n  },\n  wc_sessionRequest: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1108,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1109,\n    },\n  },\n  wc_sessionEvent: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1110,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1111,\n    },\n  },\n\n  wc_sessionDelete: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1112,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1113,\n    },\n  },\n  wc_sessionPing: {\n    req: {\n      ttl: THIRTY_SECONDS,\n      prompt: false,\n      tag: 1114,\n    },\n    res: {\n      ttl: THIRTY_SECONDS,\n      prompt: false,\n      tag: 1115,\n    },\n  },\n};\n\nexport const SESSION_REQUEST_EXPIRY_BOUNDARIES = {\n  min: FIVE_MINUTES,\n  max: SEVEN_DAYS,\n};\n\nexport const REQUEST_QUEUE_STATES: { idle: string; active: string } = {\n  idle: \"idle\",\n  active: \"active\",\n};\n","export const REQUEST_CONTEXT = \"request\";\n","export const METHODS_TO_VERIFY = [\"wc_sessionPropose\", \"wc_sessionRequest\", \"wc_authRequest\"];\n","import { EXPIRER_EVENTS, RELAYER_DEFAULT_PROTOCOL, RELAYER_EVENTS } from \"@walletconnect/core\";\n\nimport {\n  JsonRpcPayload,\n  formatJsonRpcError,\n  formatJsonRpcRequest,\n  formatJsonRpcResult,\n  getBigIntRpcId,\n  isJsonRpcError,\n  isJsonRpcRequest,\n  isJsonRpcResponse,\n  isJsonRpcResult,\n} from \"@walletconnect/jsonrpc-utils\";\nimport { FIVE_MINUTES, ONE_SECOND, toMiliseconds } from \"@walletconnect/time\";\nimport {\n  EnginePrivate,\n  EngineTypes,\n  ExpirerTypes,\n  IEngine,\n  IEngineEvents,\n  JsonRpcTypes,\n  PendingRequestTypes,\n  Verify,\n  CoreTypes,\n  ProposalTypes,\n  RelayerTypes,\n  SessionTypes,\n} from \"@walletconnect/types\";\nimport {\n  calcExpiry,\n  createDelayedPromise,\n  engineEvent,\n  getInternalError,\n  getRequiredNamespacesFromNamespaces,\n  getSdkError,\n  isConformingNamespaces,\n  isExpired,\n  isSessionCompatible,\n  isUndefined,\n  isValidController,\n  isValidErrorReason,\n  isValidEvent,\n  isValidId,\n  isValidNamespaces,\n  isValidNamespacesChainId,\n  isValidNamespacesEvent,\n  isValidNamespacesRequest,\n  isValidObject,\n  isValidParams,\n  isValidRelay,\n  isValidRelays,\n  isValidRequest,\n  isValidRequestExpiry,\n  hashMessage,\n  isBrowser,\n  isValidRequiredNamespaces,\n  isValidResponse,\n  isValidString,\n  parseExpirerTarget,\n  TYPE_1,\n  handleDeeplinkRedirect,\n} from \"@walletconnect/utils\";\nimport EventEmmiter from \"events\";\nimport {\n  ENGINE_CONTEXT,\n  ENGINE_RPC_OPTS,\n  PROPOSAL_EXPIRY_MESSAGE,\n  SESSION_EXPIRY,\n  SESSION_REQUEST_EXPIRY_BOUNDARIES,\n  METHODS_TO_VERIFY,\n  WALLETCONNECT_DEEPLINK_CHOICE,\n  REQUEST_QUEUE_STATES,\n} from \"../constants\";\n\nexport class Engine extends IEngine {\n  public name = ENGINE_CONTEXT;\n\n  private events: IEngineEvents = new EventEmmiter();\n  private initialized = false;\n  private ignoredPayloadTypes = [TYPE_1];\n  private requestQueue: {\n    state: string;\n    requests: PendingRequestTypes.Struct[];\n  } = {\n    state: REQUEST_QUEUE_STATES.idle,\n    requests: [],\n  };\n\n  private requestQueueDelay = ONE_SECOND;\n\n  constructor(client: IEngine[\"client\"]) {\n    super(client);\n  }\n\n  public init: IEngine[\"init\"] = async () => {\n    if (!this.initialized) {\n      await this.cleanup();\n      this.registerRelayerEvents();\n      this.registerExpirerEvents();\n      this.client.core.pairing.register({ methods: Object.keys(ENGINE_RPC_OPTS) });\n      this.initialized = true;\n\n      setTimeout(() => {\n        this.requestQueue.requests = this.getPendingSessionRequests();\n        this.processRequestQueue();\n      }, toMiliseconds(this.requestQueueDelay));\n    }\n  };\n\n  // ---------- Public ------------------------------------------------ //\n\n  public connect: IEngine[\"connect\"] = async (params) => {\n    this.isInitialized();\n    const connectParams = {\n      ...params,\n      requiredNamespaces: params.requiredNamespaces || {},\n      optionalNamespaces: params.optionalNamespaces || {},\n    };\n    await this.isValidConnect(connectParams);\n    const { pairingTopic, requiredNamespaces, optionalNamespaces, sessionProperties, relays } =\n      connectParams;\n    let topic = pairingTopic;\n    let uri: string | undefined;\n    let active = false;\n\n    if (topic) {\n      const pairing = this.client.core.pairing.pairings.get(topic);\n      active = pairing.active;\n    }\n\n    if (!topic || !active) {\n      const { topic: newTopic, uri: newUri } = await this.client.core.pairing.create();\n      topic = newTopic;\n      uri = newUri;\n    }\n\n    const publicKey = await this.client.core.crypto.generateKeyPair();\n\n    const proposal = {\n      requiredNamespaces,\n      optionalNamespaces,\n      relays: relays ?? [{ protocol: RELAYER_DEFAULT_PROTOCOL }],\n      proposer: {\n        publicKey,\n        metadata: this.client.metadata,\n      },\n      ...(sessionProperties && { sessionProperties }),\n    };\n    const {\n      reject,\n      resolve,\n      done: approval,\n    } = createDelayedPromise<SessionTypes.Struct>(FIVE_MINUTES, PROPOSAL_EXPIRY_MESSAGE);\n    this.events.once<\"session_connect\">(\n      engineEvent(\"session_connect\"),\n      async ({ error, session }) => {\n        if (error) reject(error);\n        else if (session) {\n          session.self.publicKey = publicKey;\n          const completeSession = {\n            ...session,\n            requiredNamespaces: session.requiredNamespaces,\n            optionalNamespaces: session.optionalNamespaces,\n          };\n          await this.client.session.set(session.topic, completeSession);\n          await this.setExpiry(session.topic, session.expiry);\n          if (topic) {\n            await this.client.core.pairing.updateMetadata({\n              topic,\n              metadata: session.peer.metadata,\n            });\n          }\n          resolve(completeSession);\n        }\n      },\n    );\n\n    if (!topic) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `connect() pairing topic: ${topic}`);\n      throw new Error(message);\n    }\n\n    const id = await this.sendRequest(topic, \"wc_sessionPropose\", proposal);\n\n    const expiry = calcExpiry(FIVE_MINUTES);\n    await this.setProposal(id, { id, expiry, ...proposal });\n    return { uri, approval };\n  };\n\n  public pair: IEngine[\"pair\"] = async (params) => {\n    this.isInitialized();\n    return await this.client.core.pairing.pair(params);\n  };\n\n  public approve: IEngine[\"approve\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidApprove(params);\n    const { id, relayProtocol, namespaces, sessionProperties } = params;\n    const proposal = this.client.proposal.get(id);\n    let { pairingTopic, proposer, requiredNamespaces, optionalNamespaces } = proposal;\n    pairingTopic = pairingTopic || \"\";\n    if (!isValidObject(requiredNamespaces)) {\n      requiredNamespaces = getRequiredNamespacesFromNamespaces(namespaces, \"approve()\");\n    }\n\n    const selfPublicKey = await this.client.core.crypto.generateKeyPair();\n    const peerPublicKey = proposer.publicKey;\n    const sessionTopic = await this.client.core.crypto.generateSharedKey(\n      selfPublicKey,\n      peerPublicKey,\n    );\n\n    if (pairingTopic && id) {\n      await this.client.core.pairing.updateMetadata({\n        topic: pairingTopic,\n        metadata: proposer.metadata,\n      });\n      await this.sendResult<\"wc_sessionPropose\">(id, pairingTopic, {\n        relay: {\n          protocol: relayProtocol ?? \"irn\",\n        },\n        responderPublicKey: selfPublicKey,\n      });\n      await this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\"));\n      await this.client.core.pairing.activate({ topic: pairingTopic });\n    }\n\n    const sessionSettle = {\n      relay: { protocol: relayProtocol ?? \"irn\" },\n      namespaces,\n      requiredNamespaces,\n      optionalNamespaces,\n      pairingTopic,\n      controller: { publicKey: selfPublicKey, metadata: this.client.metadata },\n      expiry: calcExpiry(SESSION_EXPIRY),\n      ...(sessionProperties && { sessionProperties }),\n    };\n    await this.client.core.relayer.subscribe(sessionTopic);\n    await this.sendRequest(sessionTopic, \"wc_sessionSettle\", sessionSettle);\n    const session = {\n      ...sessionSettle,\n      topic: sessionTopic,\n      pairingTopic,\n      acknowledged: false,\n      self: sessionSettle.controller,\n      peer: {\n        publicKey: proposer.publicKey,\n        metadata: proposer.metadata,\n      },\n      controller: selfPublicKey,\n    };\n    await this.client.session.set(sessionTopic, session);\n    await this.setExpiry(sessionTopic, calcExpiry(SESSION_EXPIRY));\n    return {\n      topic: sessionTopic,\n      acknowledged: () =>\n        new Promise((resolve) =>\n          setTimeout(() => resolve(this.client.session.get(sessionTopic)), 5_00),\n        ), // artificial delay to allow for the session to be processed by the peer\n    };\n  };\n\n  public reject: IEngine[\"reject\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidReject(params);\n    const { id, reason } = params;\n    const { pairingTopic } = this.client.proposal.get(id);\n    if (pairingTopic) {\n      await this.sendError(id, pairingTopic, reason);\n      await this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\"));\n    }\n  };\n\n  public update: IEngine[\"update\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidUpdate(params);\n    const { topic, namespaces } = params;\n    const id = await this.sendRequest(topic, \"wc_sessionUpdate\", { namespaces });\n    const { done: acknowledged, resolve, reject } = createDelayedPromise<void>();\n    this.events.once(engineEvent(\"session_update\", id), ({ error }) => {\n      if (error) reject(error);\n      else resolve();\n    });\n    await this.client.session.update(topic, { namespaces });\n\n    return { acknowledged };\n  };\n\n  public extend: IEngine[\"extend\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidExtend(params);\n    const { topic } = params;\n    const id = await this.sendRequest(topic, \"wc_sessionExtend\", {});\n    const { done: acknowledged, resolve, reject } = createDelayedPromise<void>();\n    this.events.once(engineEvent(\"session_extend\", id), ({ error }) => {\n      if (error) reject(error);\n      else resolve();\n    });\n    await this.setExpiry(topic, calcExpiry(SESSION_EXPIRY));\n\n    return { acknowledged };\n  };\n\n  public request: IEngine[\"request\"] = async <T>(params: EngineTypes.RequestParams) => {\n    this.isInitialized();\n    await this.isValidRequest(params);\n    const { chainId, request, topic, expiry } = params;\n    const id = await this.sendRequest(topic, \"wc_sessionRequest\", { request, chainId }, expiry);\n    const { done, resolve, reject } = createDelayedPromise<T>(expiry);\n    this.events.once<\"session_request\">(engineEvent(\"session_request\", id), ({ error, result }) => {\n      if (error) reject(error);\n      else resolve(result);\n    });\n    this.client.events.emit(\"session_request_sent\", { topic, request, chainId, id });\n    const wcDeepLink = await this.client.core.storage.getItem(WALLETCONNECT_DEEPLINK_CHOICE);\n    handleDeeplinkRedirect({ id, topic, wcDeepLink });\n    return await done();\n  };\n\n  public respond: IEngine[\"respond\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidRespond(params);\n    const { topic, response } = params;\n    const { id } = response;\n    if (isJsonRpcResult(response)) {\n      await this.sendResult(id, topic, response.result);\n    } else if (isJsonRpcError(response)) {\n      await this.sendError(id, topic, response.error);\n    }\n    this.cleanupAfterResponse(params);\n  };\n\n  public ping: IEngine[\"ping\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidPing(params);\n    const { topic } = params;\n    if (this.client.session.keys.includes(topic)) {\n      const id = await this.sendRequest(topic, \"wc_sessionPing\", {});\n      const { done, resolve, reject } = createDelayedPromise<void>();\n      this.events.once(engineEvent(\"session_ping\", id), ({ error }) => {\n        if (error) reject(error);\n        else resolve();\n      });\n      await done();\n    } else if (this.client.core.pairing.pairings.keys.includes(topic)) {\n      await this.client.core.pairing.ping({ topic });\n    }\n  };\n\n  public emit: IEngine[\"emit\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidEmit(params);\n    const { topic, event, chainId } = params;\n    await this.sendRequest(topic, \"wc_sessionEvent\", { event, chainId });\n  };\n\n  public disconnect: IEngine[\"disconnect\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidDisconnect(params);\n    const { topic } = params;\n    if (this.client.session.keys.includes(topic)) {\n      const id = getBigIntRpcId().toString() as any;\n      let resolvePromise: () => void;\n      const onDisconnectAck = (ack: JsonRpcPayload) => {\n        if (ack?.id.toString() === id) {\n          this.client.core.relayer.events.removeListener(\n            RELAYER_EVENTS.message_ack,\n            onDisconnectAck,\n          );\n          resolvePromise();\n        }\n      };\n      // await a relay ACK on the disconnect req before deleting the session, keychain etc.\n      await Promise.all([\n        new Promise<void>((resolve) => {\n          resolvePromise = resolve;\n          this.client.core.relayer.on(RELAYER_EVENTS.message_ack, onDisconnectAck);\n        }),\n        this.sendRequest(\n          topic,\n          \"wc_sessionDelete\",\n          getSdkError(\"USER_DISCONNECTED\"),\n          undefined,\n          id,\n        ),\n      ]);\n      await this.deleteSession(topic);\n    } else {\n      await this.client.core.pairing.disconnect({ topic });\n    }\n  };\n\n  public find: IEngine[\"find\"] = (params) => {\n    this.isInitialized();\n    return this.client.session.getAll().filter((session) => isSessionCompatible(session, params));\n  };\n\n  public getPendingSessionRequests: IEngine[\"getPendingSessionRequests\"] = () => {\n    this.isInitialized();\n    return this.client.pendingRequest.getAll();\n  };\n\n  // ---------- Private Helpers --------------------------------------- //\n\n  private cleanupDuplicatePairings: EnginePrivate[\"cleanupDuplicatePairings\"] = async (\n    session: SessionTypes.Struct,\n  ) => {\n    // older SDK versions are missing the `pairingTopic` prop thus we need to check for it\n    if (!session.pairingTopic) return;\n\n    try {\n      const pairing = this.client.core.pairing.pairings.get(session.pairingTopic);\n      const allPairings = this.client.core.pairing.pairings.getAll();\n      const duplicates = allPairings.filter(\n        (p) =>\n          p.peerMetadata?.url &&\n          p.peerMetadata?.url === session.peer.metadata.url &&\n          p.topic &&\n          p.topic !== pairing.topic,\n      );\n      if (duplicates.length === 0) return;\n      this.client.logger.info(`Cleaning up ${duplicates.length} duplicate pairing(s)`);\n      await Promise.all(\n        duplicates.map((p) => this.client.core.pairing.disconnect({ topic: p.topic })),\n      );\n      this.client.logger.info(`Duplicate pairings clean up finished`);\n    } catch (error) {\n      this.client.logger.error(error);\n    }\n  };\n\n  private deleteSession: EnginePrivate[\"deleteSession\"] = async (topic, expirerHasDeleted) => {\n    const { self } = this.client.session.get(topic);\n    // Await the unsubscribe first to avoid deleting the symKey too early below.\n    await this.client.core.relayer.unsubscribe(topic);\n    this.client.session.delete(topic, getSdkError(\"USER_DISCONNECTED\"));\n    if (this.client.core.crypto.keychain.has(self.publicKey)) {\n      await this.client.core.crypto.deleteKeyPair(self.publicKey);\n    }\n    if (this.client.core.crypto.keychain.has(topic)) {\n      await this.client.core.crypto.deleteSymKey(topic);\n    }\n    if (!expirerHasDeleted) this.client.core.expirer.del(topic);\n    // remove any deeplinks from storage after the session is deleted\n    // to avoid navigating to incorrect deeplink later on\n    this.client.core.storage\n      .removeItem(WALLETCONNECT_DEEPLINK_CHOICE)\n      .catch((e) => this.client.logger.warn(e));\n  };\n\n  private deleteProposal: EnginePrivate[\"deleteProposal\"] = async (id, expirerHasDeleted) => {\n    await Promise.all([\n      this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\")),\n      expirerHasDeleted ? Promise.resolve() : this.client.core.expirer.del(id),\n    ]);\n  };\n\n  private deletePendingSessionRequest: EnginePrivate[\"deletePendingSessionRequest\"] = async (\n    id,\n    reason,\n    expirerHasDeleted = false,\n  ) => {\n    await Promise.all([\n      this.client.pendingRequest.delete(id, reason),\n      expirerHasDeleted ? Promise.resolve() : this.client.core.expirer.del(id),\n    ]);\n    this.requestQueue.requests = this.requestQueue.requests.filter((r) => r.id !== id);\n    // set the requestQueue state to idle if expirer has deleted a request as trying to respond to it would result in an exception\n    if (expirerHasDeleted) {\n      this.requestQueue.state = REQUEST_QUEUE_STATES.idle;\n    }\n  };\n\n  private setExpiry: EnginePrivate[\"setExpiry\"] = async (topic, expiry) => {\n    if (this.client.session.keys.includes(topic)) {\n      await this.client.session.update(topic, { expiry });\n    }\n    this.client.core.expirer.set(topic, expiry);\n  };\n\n  private setProposal: EnginePrivate[\"setProposal\"] = async (id, proposal) => {\n    await this.client.proposal.set(id, proposal);\n    this.client.core.expirer.set(id, proposal.expiry);\n  };\n\n  private setPendingSessionRequest: EnginePrivate[\"setPendingSessionRequest\"] = async (\n    pendingRequest: PendingRequestTypes.Struct,\n  ) => {\n    const expiry = ENGINE_RPC_OPTS.wc_sessionRequest.req.ttl;\n    const { id, topic, params } = pendingRequest;\n    await this.client.pendingRequest.set(id, {\n      id,\n      topic,\n      params,\n    });\n    if (expiry) this.client.core.expirer.set(id, calcExpiry(expiry));\n  };\n\n  private sendRequest: EnginePrivate[\"sendRequest\"] = async (topic, method, params, expiry, id) => {\n    const payload = formatJsonRpcRequest(method, params);\n    if (isBrowser() && METHODS_TO_VERIFY.includes(method)) {\n      const hash = hashMessage(JSON.stringify(payload));\n      await this.client.core.verify.register({ attestationId: hash });\n    }\n    const message = await this.client.core.crypto.encode(topic, payload);\n    const opts = ENGINE_RPC_OPTS[method].req;\n    if (expiry) opts.ttl = expiry;\n    if (id) opts.id = id; // set rpc_id for client -> relay req\n    this.client.core.history.set(topic, payload);\n    this.client.core.relayer.publish(topic, message, opts);\n    return payload.id;\n  };\n\n  private sendResult: EnginePrivate[\"sendResult\"] = async (id, topic, result) => {\n    const payload = formatJsonRpcResult(id, result);\n    const message = await this.client.core.crypto.encode(topic, payload);\n    const record = await this.client.core.history.get(topic, id);\n    const opts = ENGINE_RPC_OPTS[record.request.method].res;\n    // await is intentionally omitted to speed up performance\n    this.client.core.relayer.publish(topic, message, opts);\n    await this.client.core.history.resolve(payload);\n  };\n\n  private sendError: EnginePrivate[\"sendError\"] = async (id, topic, error) => {\n    const payload = formatJsonRpcError(id, error);\n    const message = await this.client.core.crypto.encode(topic, payload);\n    const record = await this.client.core.history.get(topic, id);\n    const opts = ENGINE_RPC_OPTS[record.request.method].res;\n    // await is intentionally omitted to speed up performance\n    this.client.core.relayer.publish(topic, message, opts);\n    await this.client.core.history.resolve(payload);\n  };\n\n  private cleanup: EnginePrivate[\"cleanup\"] = async () => {\n    const sessionTopics: string[] = [];\n    const proposalIds: number[] = [];\n    this.client.session.getAll().forEach((session) => {\n      if (isExpired(session.expiry)) sessionTopics.push(session.topic);\n    });\n    this.client.proposal.getAll().forEach((proposal) => {\n      if (isExpired(proposal.expiry)) proposalIds.push(proposal.id);\n    });\n    await Promise.all([\n      ...sessionTopics.map((topic) => this.deleteSession(topic)),\n      ...proposalIds.map((id) => this.deleteProposal(id)),\n    ]);\n  };\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n\n  // ---------- Relay Events Router ----------------------------------- //\n\n  private registerRelayerEvents() {\n    this.client.core.relayer.on(\n      RELAYER_EVENTS.message,\n      async (event: RelayerTypes.MessageEvent) => {\n        const { topic, message } = event;\n\n        // messages of certain types should be ignored as they are handled by their respective SDKs\n        if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(message))) {\n          return;\n        }\n\n        const payload = await this.client.core.crypto.decode(topic, message);\n        try {\n          if (isJsonRpcRequest(payload)) {\n            this.client.core.history.set(topic, payload);\n            this.onRelayEventRequest({ topic, payload });\n          } else if (isJsonRpcResponse(payload)) {\n            await this.client.core.history.resolve(payload);\n            await this.onRelayEventResponse({ topic, payload });\n            this.client.core.history.delete(topic, payload.id);\n          } else {\n            this.onRelayEventUnknownPayload({ topic, payload });\n          }\n        } catch (error) {\n          this.client.logger.error(error);\n        }\n      },\n    );\n  }\n\n  private onRelayEventRequest: EnginePrivate[\"onRelayEventRequest\"] = (event) => {\n    const { topic, payload } = event;\n    const reqMethod = payload.method as JsonRpcTypes.WcMethod;\n\n    switch (reqMethod) {\n      case \"wc_sessionPropose\":\n        return this.onSessionProposeRequest(topic, payload);\n      case \"wc_sessionSettle\":\n        return this.onSessionSettleRequest(topic, payload);\n      case \"wc_sessionUpdate\":\n        return this.onSessionUpdateRequest(topic, payload);\n      case \"wc_sessionExtend\":\n        return this.onSessionExtendRequest(topic, payload);\n      case \"wc_sessionPing\":\n        return this.onSessionPingRequest(topic, payload);\n      case \"wc_sessionDelete\":\n        return this.onSessionDeleteRequest(topic, payload);\n      case \"wc_sessionRequest\":\n        return this.onSessionRequest(topic, payload);\n      case \"wc_sessionEvent\":\n        return this.onSessionEventRequest(topic, payload);\n      default:\n        return this.client.logger.info(`Unsupported request method ${reqMethod}`);\n    }\n  };\n\n  private onRelayEventResponse: EnginePrivate[\"onRelayEventResponse\"] = async (event) => {\n    const { topic, payload } = event;\n    const record = await this.client.core.history.get(topic, payload.id);\n    const resMethod = record.request.method as JsonRpcTypes.WcMethod;\n    switch (resMethod) {\n      case \"wc_sessionPropose\":\n        return this.onSessionProposeResponse(topic, payload);\n      case \"wc_sessionSettle\":\n        return this.onSessionSettleResponse(topic, payload);\n      case \"wc_sessionUpdate\":\n        return this.onSessionUpdateResponse(topic, payload);\n      case \"wc_sessionExtend\":\n        return this.onSessionExtendResponse(topic, payload);\n      case \"wc_sessionPing\":\n        return this.onSessionPingResponse(topic, payload);\n      case \"wc_sessionRequest\":\n        return this.onSessionRequestResponse(topic, payload);\n      default:\n        return this.client.logger.info(`Unsupported response method ${resMethod}`);\n    }\n  };\n\n  private onRelayEventUnknownPayload: EnginePrivate[\"onRelayEventUnknownPayload\"] = (event) => {\n    const { topic } = event;\n    const { message } = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `Decoded payload on topic ${topic} is not identifiable as a JSON-RPC request or a response.`,\n    );\n    throw new Error(message);\n  };\n\n  // ---------- Relay Events Handlers --------------------------------- //\n\n  private onSessionProposeRequest: EnginePrivate[\"onSessionProposeRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { params, id } = payload;\n    try {\n      this.isValidConnect({ ...payload.params });\n      const expiry = calcExpiry(FIVE_MINUTES);\n      const proposal = { id, pairingTopic: topic, expiry, ...params };\n      await this.setProposal(id, proposal);\n      const hash = hashMessage(JSON.stringify(payload));\n      const verifyContext = await this.getVerifyContext(hash, proposal.proposer.metadata);\n      this.client.events.emit(\"session_proposal\", { id, params: proposal, verifyContext });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionProposeResponse: EnginePrivate[\"onSessionProposeResponse\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      const { result } = payload;\n      this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", result });\n      const proposal = this.client.proposal.get(id);\n      this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", proposal });\n      const selfPublicKey = proposal.proposer.publicKey;\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        selfPublicKey,\n      });\n      const peerPublicKey = result.responderPublicKey;\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        peerPublicKey,\n      });\n      const sessionTopic = await this.client.core.crypto.generateSharedKey(\n        selfPublicKey,\n        peerPublicKey,\n      );\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        sessionTopic,\n      });\n      const subscriptionId = await this.client.core.relayer.subscribe(sessionTopic);\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        subscriptionId,\n      });\n      await this.client.core.pairing.activate({ topic });\n    } else if (isJsonRpcError(payload)) {\n      await this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\"));\n      this.events.emit(engineEvent(\"session_connect\"), { error: payload.error });\n    }\n  };\n\n  private onSessionSettleRequest: EnginePrivate[\"onSessionSettleRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id, params } = payload;\n    try {\n      this.isValidSessionSettleRequest(params);\n      const {\n        relay,\n        controller,\n        expiry,\n        namespaces,\n        requiredNamespaces,\n        optionalNamespaces,\n        sessionProperties,\n        pairingTopic,\n      } = payload.params;\n      const session = {\n        topic,\n        relay,\n        expiry,\n        namespaces,\n        acknowledged: true,\n        pairingTopic,\n        requiredNamespaces,\n        optionalNamespaces,\n        controller: controller.publicKey,\n        self: {\n          publicKey: \"\",\n          metadata: this.client.metadata,\n        },\n        peer: {\n          publicKey: controller.publicKey,\n          metadata: controller.metadata,\n        },\n        ...(sessionProperties && { sessionProperties }),\n      };\n      await this.sendResult<\"wc_sessionSettle\">(payload.id, topic, true);\n      this.events.emit(engineEvent(\"session_connect\"), { session });\n      this.cleanupDuplicatePairings(session);\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionSettleResponse: EnginePrivate[\"onSessionSettleResponse\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      await this.client.session.update(topic, { acknowledged: true });\n      this.events.emit(engineEvent(\"session_approve\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      await this.client.session.delete(topic, getSdkError(\"USER_DISCONNECTED\"));\n      this.events.emit(engineEvent(\"session_approve\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionUpdateRequest: EnginePrivate[\"onSessionUpdateRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { params, id } = payload;\n    try {\n      this.isValidUpdate({ topic, ...params });\n      await this.client.session.update(topic, { namespaces: params.namespaces });\n      await this.sendResult<\"wc_sessionUpdate\">(id, topic, true);\n      this.client.events.emit(\"session_update\", { id, topic, params });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionUpdateResponse: EnginePrivate[\"onSessionUpdateResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_update\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_update\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionExtendRequest: EnginePrivate[\"onSessionExtendRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    try {\n      this.isValidExtend({ topic });\n      await this.setExpiry(topic, calcExpiry(SESSION_EXPIRY));\n      await this.sendResult<\"wc_sessionExtend\">(id, topic, true);\n      this.client.events.emit(\"session_extend\", { id, topic });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionExtendResponse: EnginePrivate[\"onSessionExtendResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_extend\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_extend\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionPingRequest: EnginePrivate[\"onSessionPingRequest\"] = async (topic, payload) => {\n    const { id } = payload;\n    try {\n      this.isValidPing({ topic });\n      await this.sendResult<\"wc_sessionPing\">(id, topic, true);\n      this.client.events.emit(\"session_ping\", { id, topic });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionPingResponse: EnginePrivate[\"onSessionPingResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    // put at the end of the stack to avoid a race condition\n    // where session_ping listener is not yet initialized\n    setTimeout(() => {\n      if (isJsonRpcResult(payload)) {\n        this.events.emit(engineEvent(\"session_ping\", id), {});\n      } else if (isJsonRpcError(payload)) {\n        this.events.emit(engineEvent(\"session_ping\", id), { error: payload.error });\n      }\n    }, 500);\n  };\n\n  private onSessionDeleteRequest: EnginePrivate[\"onSessionDeleteRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    try {\n      this.isValidDisconnect({ topic, reason: payload.params });\n      await Promise.all([\n        new Promise((resolve) => {\n          // RPC request needs to happen before deletion as it utalises session encryption\n          this.client.core.relayer.once(RELAYER_EVENTS.publish, async () => {\n            resolve(await this.deleteSession(topic));\n          });\n        }),\n        this.sendResult<\"wc_sessionDelete\">(id, topic, true),\n      ]);\n      this.client.events.emit(\"session_delete\", { id, topic });\n    } catch (err: any) {\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionRequest: EnginePrivate[\"onSessionRequest\"] = async (topic, payload) => {\n    const { id, params } = payload;\n    try {\n      this.isValidRequest({ topic, ...params });\n      await this.setPendingSessionRequest({ id, topic, params });\n      this.addRequestToQueue({ id, topic, params });\n      await this.processRequestQueue();\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionRequestResponse: EnginePrivate[\"onSessionRequestResponse\"] = (\n    _topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { result: payload.result });\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionEventRequest: EnginePrivate[\"onSessionEventRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id, params } = payload;\n    try {\n      this.isValidEmit({ topic, ...params });\n      this.client.events.emit(\"session_event\", { id, topic, params });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private addRequestToQueue = (request: PendingRequestTypes.Struct) => {\n    this.requestQueue.requests.push(request);\n  };\n\n  private cleanupAfterResponse = (params: EngineTypes.RespondParams) => {\n    this.deletePendingSessionRequest(params.response.id, { message: \"fulfilled\", code: 0 });\n    // intentionally delay the emitting of the next pending request a bit\n    setTimeout(() => {\n      this.requestQueue.state = REQUEST_QUEUE_STATES.idle;\n      this.processRequestQueue();\n    }, toMiliseconds(this.requestQueueDelay));\n  };\n\n  private processRequestQueue = async () => {\n    if (this.requestQueue.state === REQUEST_QUEUE_STATES.active) {\n      this.client.logger.info(\"session request queue is already active.\");\n      return;\n    }\n    // Select the first/oldest request in the array to ensure last-in-first-out (LIFO)\n    const request = this.requestQueue.requests[0];\n    if (!request) {\n      this.client.logger.info(\"session request queue is empty.\");\n      return;\n    }\n\n    try {\n      const { id, topic, params } = request;\n      const hash = hashMessage(JSON.stringify({ id, params }));\n      const session = this.client.session.get(topic);\n      const verifyContext = await this.getVerifyContext(hash, session.peer.metadata);\n      this.requestQueue.state = REQUEST_QUEUE_STATES.active;\n      this.client.events.emit(\"session_request\", { id, topic, params, verifyContext });\n    } catch (error) {\n      this.client.logger.error(error);\n    }\n  };\n\n  // ---------- Expirer Events ---------------------------------------- //\n\n  private registerExpirerEvents() {\n    this.client.core.expirer.on(EXPIRER_EVENTS.expired, async (event: ExpirerTypes.Expiration) => {\n      const { topic, id } = parseExpirerTarget(event.target);\n      if (id && this.client.pendingRequest.keys.includes(id)) {\n        return await this.deletePendingSessionRequest(id, getInternalError(\"EXPIRED\"), true);\n      }\n\n      if (topic) {\n        if (this.client.session.keys.includes(topic)) {\n          await this.deleteSession(topic, true);\n          this.client.events.emit(\"session_expire\", { topic });\n        }\n      } else if (id) {\n        await this.deleteProposal(id, true);\n        this.client.events.emit(\"proposal_expire\", { id });\n      }\n    });\n  }\n\n  // ---------- Validation Helpers ------------------------------------ //\n  private isValidPairingTopic(topic: any) {\n    if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `pairing topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (!this.client.core.pairing.pairings.keys.includes(topic)) {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `pairing topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (isExpired(this.client.core.pairing.pairings.get(topic).expiry)) {\n      // await this.deletePairing(topic);\n      const { message } = getInternalError(\"EXPIRED\", `pairing topic: ${topic}`);\n      throw new Error(message);\n    }\n  }\n\n  private async isValidSessionTopic(topic: any) {\n    if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `session topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (!this.client.session.keys.includes(topic)) {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `session topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (isExpired(this.client.session.get(topic).expiry)) {\n      await this.deleteSession(topic);\n      const { message } = getInternalError(\"EXPIRED\", `session topic: ${topic}`);\n      throw new Error(message);\n    }\n  }\n\n  private async isValidSessionOrPairingTopic(topic: string) {\n    if (this.client.session.keys.includes(topic)) {\n      await this.isValidSessionTopic(topic);\n    } else if (this.client.core.pairing.pairings.keys.includes(topic)) {\n      this.isValidPairingTopic(topic);\n    } else if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `session or pairing topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    } else {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `session or pairing topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n  }\n\n  private async isValidProposalId(id: any) {\n    if (!isValidId(id)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `proposal id should be a number: ${id}`,\n      );\n      throw new Error(message);\n    }\n    if (!this.client.proposal.keys.includes(id)) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `proposal id doesn't exist: ${id}`);\n      throw new Error(message);\n    }\n    if (isExpired(this.client.proposal.get(id).expiry)) {\n      await this.deleteProposal(id);\n      const { message } = getInternalError(\"EXPIRED\", `proposal id: ${id}`);\n      throw new Error(message);\n    }\n  }\n\n  // ---------- Validation  ------------------------------------------- //\n\n  private isValidConnect: EnginePrivate[\"isValidConnect\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `connect() params: ${JSON.stringify(params)}`,\n      );\n      throw new Error(message);\n    }\n    const { pairingTopic, requiredNamespaces, optionalNamespaces, sessionProperties, relays } =\n      params;\n    if (!isUndefined(pairingTopic)) await this.isValidPairingTopic(pairingTopic);\n\n    if (!isValidRelays(relays, true)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `connect() relays: ${relays}`);\n      throw new Error(message);\n    }\n\n    // validate required namespaces only if they are defined\n    if (!isUndefined(requiredNamespaces) && isValidObject(requiredNamespaces) !== 0) {\n      this.validateNamespaces(requiredNamespaces, \"requiredNamespaces\");\n    }\n\n    // validate optional namespaces only if they are defined\n    if (!isUndefined(optionalNamespaces) && isValidObject(optionalNamespaces) !== 0) {\n      this.validateNamespaces(optionalNamespaces, \"optionalNamespaces\");\n    }\n\n    // validate session properties only if they are defined\n    if (!isUndefined(sessionProperties)) {\n      this.validateSessionProps(sessionProperties, \"sessionProperties\");\n    }\n  };\n\n  private validateNamespaces = (\n    namespaces: ProposalTypes.RequiredNamespaces | ProposalTypes.OptionalNamespaces,\n    type: string,\n  ) => {\n    const validRequiredNamespacesError = isValidRequiredNamespaces(namespaces, \"connect()\", type);\n    if (validRequiredNamespacesError) throw new Error(validRequiredNamespacesError.message);\n  };\n\n  private isValidApprove: EnginePrivate[\"isValidApprove\"] = async (params) => {\n    if (!isValidParams(params))\n      throw new Error(\n        getInternalError(\"MISSING_OR_INVALID\", `approve() params: ${params}`).message,\n      );\n    const { id, namespaces, relayProtocol, sessionProperties } = params;\n    await this.isValidProposalId(id);\n    const proposal = this.client.proposal.get(id);\n    const validNamespacesError = isValidNamespaces(namespaces, \"approve()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    const conformingNamespacesError = isConformingNamespaces(\n      proposal.requiredNamespaces,\n      namespaces,\n      \"approve()\",\n    );\n    if (conformingNamespacesError) throw new Error(conformingNamespacesError.message);\n    if (!isValidString(relayProtocol, true)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `approve() relayProtocol: ${relayProtocol}`,\n      );\n      throw new Error(message);\n    }\n\n    if (!isUndefined(sessionProperties)) {\n      this.validateSessionProps(sessionProperties, \"sessionProperties\");\n    }\n  };\n\n  private isValidReject: EnginePrivate[\"isValidReject\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `reject() params: ${params}`);\n      throw new Error(message);\n    }\n    const { id, reason } = params;\n    await this.isValidProposalId(id);\n    if (!isValidErrorReason(reason)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `reject() reason: ${JSON.stringify(reason)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidSessionSettleRequest: EnginePrivate[\"isValidSessionSettleRequest\"] = (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `onSessionSettleRequest() params: ${params}`,\n      );\n      throw new Error(message);\n    }\n    const { relay, controller, namespaces, expiry } = params;\n    if (!isValidRelay(relay)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `onSessionSettleRequest() relay protocol should be a string`,\n      );\n      throw new Error(message);\n    }\n    const validControllerError = isValidController(controller, \"onSessionSettleRequest()\");\n    if (validControllerError) throw new Error(validControllerError.message);\n    const validNamespacesError = isValidNamespaces(namespaces, \"onSessionSettleRequest()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    if (isExpired(expiry)) {\n      const { message } = getInternalError(\"EXPIRED\", `onSessionSettleRequest()`);\n      throw new Error(message);\n    }\n  };\n\n  private isValidUpdate: EnginePrivate[\"isValidUpdate\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `update() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, namespaces } = params;\n    await this.isValidSessionTopic(topic);\n    const session = this.client.session.get(topic);\n    const validNamespacesError = isValidNamespaces(namespaces, \"update()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    const conformingNamespacesError = isConformingNamespaces(\n      session.requiredNamespaces,\n      namespaces,\n      \"update()\",\n    );\n    if (conformingNamespacesError) throw new Error(conformingNamespacesError.message);\n    // TODO(ilja) - check if wallet\n  };\n\n  private isValidExtend: EnginePrivate[\"isValidExtend\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `extend() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidSessionTopic(topic);\n    // TODO(ilja) - check if wallet\n  };\n\n  private isValidRequest: EnginePrivate[\"isValidRequest\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `request() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, request, chainId, expiry } = params;\n    await this.isValidSessionTopic(topic);\n    const { namespaces } = this.client.session.get(topic);\n    if (!isValidNamespacesChainId(namespaces, chainId)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `request() chainId: ${chainId}`);\n      throw new Error(message);\n    }\n    if (!isValidRequest(request)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() ${JSON.stringify(request)}`,\n      );\n      throw new Error(message);\n    }\n    if (!isValidNamespacesRequest(namespaces, chainId, request.method)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() method: ${request.method}`,\n      );\n      throw new Error(message);\n    }\n    if (expiry && !isValidRequestExpiry(expiry, SESSION_REQUEST_EXPIRY_BOUNDARIES)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() expiry: ${expiry}. Expiry must be a number (in seconds) between ${SESSION_REQUEST_EXPIRY_BOUNDARIES.min} and ${SESSION_REQUEST_EXPIRY_BOUNDARIES.max}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidRespond: EnginePrivate[\"isValidRespond\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `respond() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, response } = params;\n    await this.isValidSessionTopic(topic);\n    if (!isValidResponse(response)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `respond() response: ${JSON.stringify(response)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidPing: EnginePrivate[\"isValidPing\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `ping() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidSessionOrPairingTopic(topic);\n  };\n\n  private isValidEmit: EnginePrivate[\"isValidEmit\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `emit() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, event, chainId } = params;\n    await this.isValidSessionTopic(topic);\n    const { namespaces } = this.client.session.get(topic);\n    if (!isValidNamespacesChainId(namespaces, chainId)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `emit() chainId: ${chainId}`);\n      throw new Error(message);\n    }\n    if (!isValidEvent(event)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `emit() event: ${JSON.stringify(event)}`,\n      );\n      throw new Error(message);\n    }\n    if (!isValidNamespacesEvent(namespaces, chainId, event.name)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `emit() event: ${JSON.stringify(event)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidDisconnect: EnginePrivate[\"isValidDisconnect\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `disconnect() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidSessionOrPairingTopic(topic);\n  };\n\n  private getVerifyContext = async (hash: string, metadata: CoreTypes.Metadata) => {\n    const context: Verify.Context = {\n      verified: {\n        verifyUrl: metadata.verifyUrl || \"\",\n        validation: \"UNKNOWN\",\n        origin: metadata.url || \"\",\n      },\n    };\n\n    try {\n      const origin = await this.client.core.verify.resolve({\n        attestationId: hash,\n        verifyUrl: metadata.verifyUrl,\n      });\n      if (origin) {\n        context.verified.origin = origin;\n        context.verified.validation = origin === metadata.url ? \"VALID\" : \"INVALID\";\n      }\n    } catch (e) {\n      this.client.logger.error(e);\n    }\n\n    this.client.logger.info(`Verify context: ${JSON.stringify(context)}`);\n    return context;\n  };\n\n  private validateSessionProps = (properties: ProposalTypes.SessionProperties, type: string) => {\n    Object.values(properties).forEach((property) => {\n      if (!isValidString(property, false)) {\n        const { message } = getInternalError(\n          \"MISSING_OR_INVALID\",\n          `${type} must be in Record<string, string> format. Received: ${JSON.stringify(property)}`,\n        );\n        throw new Error(message);\n      }\n    });\n  };\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore, ProposalTypes } from \"@walletconnect/types\";\n\nimport { SIGN_CLIENT_STORAGE_PREFIX, PROPOSAL_CONTEXT } from \"../constants\";\n\nexport class Proposal extends Store<number, ProposalTypes.Struct> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(core, logger, PROPOSAL_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX);\n  }\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore, SessionTypes } from \"@walletconnect/types\";\n\nimport { SIGN_CLIENT_STORAGE_PREFIX, SESSION_CONTEXT } from \"../constants\";\n\nexport class Session extends Store<string, SessionTypes.Struct> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(core, logger, SESSION_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX);\n  }\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore, PendingRequestTypes } from \"@walletconnect/types\";\nimport { REQUEST_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX } from \"../constants\";\n\nexport class PendingRequest extends Store<number, PendingRequestTypes.Struct> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(\n      core,\n      logger,\n      REQUEST_CONTEXT,\n      SIGN_CLIENT_STORAGE_PREFIX,\n      (val: PendingRequestTypes.Struct) => val.id,\n    );\n  }\n}\n","import { Core } from \"@walletconnect/core\";\nimport {\n  generateChildLogger,\n  getDefaultLoggerOptions,\n  getLoggerContext,\n  pino,\n} from \"@walletconnect/logger\";\nimport { SignClientTypes, ISignClient, ISignClientEvents, EngineTypes } from \"@walletconnect/types\";\nimport { getAppMetadata } from \"@walletconnect/utils\";\nimport { EventEmitter } from \"events\";\nimport { SIGN_CLIENT_DEFAULT, SIGN_CLIENT_PROTOCOL, SIGN_CLIENT_VERSION } from \"./constants\";\nimport { Engine, PendingRequest, Proposal, Session } from \"./controllers\";\n\nexport class SignClient extends ISignClient {\n  public readonly protocol = SIGN_CLIENT_PROTOCOL;\n  public readonly version = SIGN_CLIENT_VERSION;\n  public readonly name: ISignClient[\"name\"] = SIGN_CLIENT_DEFAULT.name;\n  public readonly metadata: ISignClient[\"metadata\"];\n\n  public core: ISignClient[\"core\"];\n  public logger: ISignClient[\"logger\"];\n  public events: ISignClient[\"events\"] = new EventEmitter();\n  public engine: ISignClient[\"engine\"];\n  public session: ISignClient[\"session\"];\n  public proposal: ISignClient[\"proposal\"];\n  public pendingRequest: ISignClient[\"pendingRequest\"];\n\n  static async init(opts?: SignClientTypes.Options) {\n    const client = new SignClient(opts);\n    await client.initialize();\n\n    return client;\n  }\n\n  constructor(opts?: SignClientTypes.Options) {\n    super(opts);\n\n    this.name = opts?.name || SIGN_CLIENT_DEFAULT.name;\n    this.metadata = opts?.metadata || getAppMetadata();\n\n    const logger =\n      typeof opts?.logger !== \"undefined\" && typeof opts?.logger !== \"string\"\n        ? opts.logger\n        : pino(getDefaultLoggerOptions({ level: opts?.logger || SIGN_CLIENT_DEFAULT.logger }));\n\n    this.core = opts?.core || new Core(opts);\n    this.logger = generateChildLogger(logger, this.name);\n    this.session = new Session(this.core, this.logger);\n    this.proposal = new Proposal(this.core, this.logger);\n    this.pendingRequest = new PendingRequest(this.core, this.logger);\n    this.engine = new Engine(this);\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get pairing() {\n    return this.core.pairing.pairings;\n  }\n\n  // ---------- Events ----------------------------------------------- //\n\n  public on: ISignClientEvents[\"on\"] = (name, listener) => {\n    return this.events.on(name, listener);\n  };\n\n  public once: ISignClientEvents[\"once\"] = (name, listener) => {\n    return this.events.once(name, listener);\n  };\n\n  public off: ISignClientEvents[\"off\"] = (name, listener) => {\n    return this.events.off(name, listener);\n  };\n\n  public removeListener: ISignClientEvents[\"removeListener\"] = (name, listener) => {\n    return this.events.removeListener(name, listener);\n  };\n\n  public removeAllListeners: ISignClientEvents[\"removeAllListeners\"] = (name) => {\n    return this.events.removeAllListeners(name);\n  };\n\n  // ---------- Engine ----------------------------------------------- //\n\n  public connect: ISignClient[\"connect\"] = async (params) => {\n    try {\n      return await this.engine.connect(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public pair: ISignClient[\"pair\"] = async (params) => {\n    try {\n      return await this.engine.pair(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public approve: ISignClient[\"approve\"] = async (params) => {\n    try {\n      return await this.engine.approve(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public reject: ISignClient[\"reject\"] = async (params) => {\n    try {\n      return await this.engine.reject(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public update: ISignClient[\"update\"] = async (params) => {\n    try {\n      return await this.engine.update(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public extend: ISignClient[\"extend\"] = async (params) => {\n    try {\n      return await this.engine.extend(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public request: ISignClient[\"request\"] = async <T>(params: EngineTypes.RequestParams) => {\n    try {\n      return await this.engine.request<T>(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public respond: ISignClient[\"respond\"] = async (params) => {\n    try {\n      return await this.engine.respond(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public ping: ISignClient[\"ping\"] = async (params) => {\n    try {\n      return await this.engine.ping(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public emit: ISignClient[\"emit\"] = async (params) => {\n    try {\n      return await this.engine.emit(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public disconnect: ISignClient[\"disconnect\"] = async (params) => {\n    try {\n      return await this.engine.disconnect(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public find: ISignClient[\"find\"] = (params) => {\n    try {\n      return this.engine.find(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public getPendingSessionRequests: ISignClient[\"getPendingSessionRequests\"] = () => {\n    try {\n      return this.engine.getPendingSessionRequests();\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async initialize() {\n    this.logger.trace(`Initialized`);\n    try {\n      await this.core.start();\n      await this.session.init();\n      await this.proposal.init();\n      await this.pendingRequest.init();\n      await this.engine.init();\n      this.core.verify.init({ verifyUrl: this.metadata.verifyUrl });\n      this.logger.info(`SignClient Initialization Success`);\n    } catch (error: any) {\n      this.logger.info(`SignClient Initialization Failure`);\n      this.logger.error(error.message);\n      throw error;\n    }\n  }\n}\n","import { SignClient as Client } from \"./client\";\n\nexport * from \"./constants\";\n\nexport const SignClient = Client;\nexport default Client;\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}