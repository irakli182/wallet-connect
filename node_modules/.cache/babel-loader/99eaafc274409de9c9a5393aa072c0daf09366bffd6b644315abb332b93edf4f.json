{"ast":null,"code":"import { BytesSizeMismatchError } from '../errors/abi.js';\nimport { InvalidAddressError } from '../errors/address.js';\nimport { isAddress } from './address/isAddress.js';\nimport { size } from './data/size.js';\nimport { numberToHex } from './encoding/toHex.js';\nimport { bytesRegex, integerRegex } from './regex.js';\nexport function validateTypedData({\n  domain,\n  message,\n  primaryType,\n  types: types_\n}) {\n  const types = types_;\n  const validateData = (struct, value_) => {\n    for (const param of struct) {\n      const {\n        name,\n        type: type_\n      } = param;\n      const type = type_;\n      const value = value_[name];\n      const integerMatch = type.match(integerRegex);\n      if (integerMatch && (typeof value === 'number' || typeof value === 'bigint')) {\n        const [_type, base, size_] = integerMatch;\n        // If number cannot be cast to a sized hex value, it is out of range\n        // and will throw.\n        numberToHex(value, {\n          signed: base === 'int',\n          size: parseInt(size_) / 8\n        });\n      }\n      if (type === 'address' && typeof value === 'string' && !isAddress(value)) throw new InvalidAddressError({\n        address: value\n      });\n      const bytesMatch = type.match(bytesRegex);\n      if (bytesMatch) {\n        const [_type, size_] = bytesMatch;\n        if (size_ && size(value) !== parseInt(size_)) throw new BytesSizeMismatchError({\n          expectedSize: parseInt(size_),\n          givenSize: size(value)\n        });\n      }\n      const struct = types[type];\n      if (struct) validateData(struct, value);\n    }\n  };\n  // Validate domain types.\n  if (types['EIP712Domain'] && domain) validateData(types['EIP712Domain'], domain);\n  if (primaryType !== 'EIP712Domain') {\n    // Validate message types.\n    const type = types[primaryType];\n    validateData(type, message);\n  }\n}","map":{"version":3,"names":["BytesSizeMismatchError","InvalidAddressError","isAddress","size","numberToHex","bytesRegex","integerRegex","validateTypedData","domain","message","primaryType","types","types_","validateData","struct","value_","param","name","type","type_","value","integerMatch","match","_type","base","size_","signed","parseInt","address","bytesMatch","expectedSize","givenSize"],"sources":["C:\\Users\\irakl\\OneDrive\\Desktop\\wallet-connect\\node_modules\\viem\\src\\utils\\typedData.ts"],"sourcesContent":["import type { TypedData, TypedDataParameter, TypedDataType } from 'abitype'\n\nimport { BytesSizeMismatchError } from '../errors/abi.js'\nimport { InvalidAddressError } from '../errors/address.js'\nimport type { Hex } from '../types/misc.js'\nimport type { TypedDataDefinition } from '../types/typedData.js'\n\nimport { isAddress } from './address/isAddress.js'\nimport { size } from './data/size.js'\nimport { numberToHex } from './encoding/toHex.js'\nimport { bytesRegex, integerRegex } from './regex.js'\n\nexport function validateTypedData<\n  TTypedData extends TypedData | { [key: string]: unknown },\n  TPrimaryType extends string = string,\n>({\n  domain,\n  message,\n  primaryType,\n  types: types_,\n}: TypedDataDefinition<TTypedData, TPrimaryType>) {\n  const types = types_ as TypedData\n\n  const validateData = (\n    struct: readonly TypedDataParameter[],\n    value_: Record<string, unknown>,\n  ) => {\n    for (const param of struct) {\n      const { name, type: type_ } = param\n      const type = type_ as TypedDataType\n      const value = value_[name]\n\n      const integerMatch = type.match(integerRegex)\n      if (\n        integerMatch &&\n        (typeof value === 'number' || typeof value === 'bigint')\n      ) {\n        const [_type, base, size_] = integerMatch\n        // If number cannot be cast to a sized hex value, it is out of range\n        // and will throw.\n        numberToHex(value, {\n          signed: base === 'int',\n          size: parseInt(size_) / 8,\n        })\n      }\n\n      if (type === 'address' && typeof value === 'string' && !isAddress(value))\n        throw new InvalidAddressError({ address: value })\n\n      const bytesMatch = type.match(bytesRegex)\n      if (bytesMatch) {\n        const [_type, size_] = bytesMatch\n        if (size_ && size(value as Hex) !== parseInt(size_))\n          throw new BytesSizeMismatchError({\n            expectedSize: parseInt(size_),\n            givenSize: size(value as Hex),\n          })\n      }\n\n      const struct = types[type]\n      if (struct) validateData(struct, value as Record<string, unknown>)\n    }\n  }\n\n  // Validate domain types.\n  if (types['EIP712Domain'] && domain)\n    validateData(types['EIP712Domain'], domain)\n\n  if (primaryType !== 'EIP712Domain') {\n    // Validate message types.\n    const type = types[primaryType]\n    validateData(type, message as Record<string, unknown>)\n  }\n}\n"],"mappings":"AAEA,SAASA,sBAAsB,QAAQ,kBAAkB;AACzD,SAASC,mBAAmB,QAAQ,sBAAsB;AAI1D,SAASC,SAAS,QAAQ,wBAAwB;AAClD,SAASC,IAAI,QAAQ,gBAAgB;AACrC,SAASC,WAAW,QAAQ,qBAAqB;AACjD,SAASC,UAAU,EAAEC,YAAY,QAAQ,YAAY;AAErD,OAAM,SAAUC,iBAAiBA,CAG/B;EACAC,MAAM;EACNC,OAAO;EACPC,WAAW;EACXC,KAAK,EAAEC;AAAM,CACiC;EAC9C,MAAMD,KAAK,GAAGC,MAAmB;EAEjC,MAAMC,YAAY,GAAGA,CACnBC,MAAqC,EACrCC,MAA+B,KAC7B;IACF,KAAK,MAAMC,KAAK,IAAIF,MAAM,EAAE;MAC1B,MAAM;QAAEG,IAAI;QAAEC,IAAI,EAAEC;MAAK,CAAE,GAAGH,KAAK;MACnC,MAAME,IAAI,GAAGC,KAAsB;MACnC,MAAMC,KAAK,GAAGL,MAAM,CAACE,IAAI,CAAC;MAE1B,MAAMI,YAAY,GAAGH,IAAI,CAACI,KAAK,CAAChB,YAAY,CAAC;MAC7C,IACEe,YAAY,KACX,OAAOD,KAAK,KAAK,QAAQ,IAAI,OAAOA,KAAK,KAAK,QAAQ,CAAC,EACxD;QACA,MAAM,CAACG,KAAK,EAAEC,IAAI,EAAEC,KAAK,CAAC,GAAGJ,YAAY;QACzC;QACA;QACAjB,WAAW,CAACgB,KAAK,EAAE;UACjBM,MAAM,EAAEF,IAAI,KAAK,KAAK;UACtBrB,IAAI,EAAEwB,QAAQ,CAACF,KAAK,CAAC,GAAG;SACzB,CAAC;;MAGJ,IAAIP,IAAI,KAAK,SAAS,IAAI,OAAOE,KAAK,KAAK,QAAQ,IAAI,CAAClB,SAAS,CAACkB,KAAK,CAAC,EACtE,MAAM,IAAInB,mBAAmB,CAAC;QAAE2B,OAAO,EAAER;MAAK,CAAE,CAAC;MAEnD,MAAMS,UAAU,GAAGX,IAAI,CAACI,KAAK,CAACjB,UAAU,CAAC;MACzC,IAAIwB,UAAU,EAAE;QACd,MAAM,CAACN,KAAK,EAAEE,KAAK,CAAC,GAAGI,UAAU;QACjC,IAAIJ,KAAK,IAAItB,IAAI,CAACiB,KAAY,CAAC,KAAKO,QAAQ,CAACF,KAAK,CAAC,EACjD,MAAM,IAAIzB,sBAAsB,CAAC;UAC/B8B,YAAY,EAAEH,QAAQ,CAACF,KAAK,CAAC;UAC7BM,SAAS,EAAE5B,IAAI,CAACiB,KAAY;SAC7B,CAAC;;MAGN,MAAMN,MAAM,GAAGH,KAAK,CAACO,IAAI,CAAC;MAC1B,IAAIJ,MAAM,EAAED,YAAY,CAACC,MAAM,EAAEM,KAAgC,CAAC;;EAEtE,CAAC;EAED;EACA,IAAIT,KAAK,CAAC,cAAc,CAAC,IAAIH,MAAM,EACjCK,YAAY,CAACF,KAAK,CAAC,cAAc,CAAC,EAAEH,MAAM,CAAC;EAE7C,IAAIE,WAAW,KAAK,cAAc,EAAE;IAClC;IACA,MAAMQ,IAAI,GAAGP,KAAK,CAACD,WAAW,CAAC;IAC/BG,YAAY,CAACK,IAAI,EAAET,OAAkC,CAAC;;AAE1D"},"metadata":{},"sourceType":"module","externalDependencies":[]}