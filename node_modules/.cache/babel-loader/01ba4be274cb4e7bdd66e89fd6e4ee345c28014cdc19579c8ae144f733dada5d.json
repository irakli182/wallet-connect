{"ast":null,"code":"import { isAddress } from '../address/isAddress.js';\nexport function getAbiItem({\n  abi,\n  args = [],\n  name\n}) {\n  const abiItems = abi.filter(x => 'name' in x && x.name === name);\n  if (abiItems.length === 0) return undefined;\n  if (abiItems.length === 1) return abiItems[0];\n  for (const abiItem of abiItems) {\n    if (!('inputs' in abiItem)) continue;\n    if (!args || args.length === 0) {\n      if (!abiItem.inputs || abiItem.inputs.length === 0) return abiItem;\n      continue;\n    }\n    if (!abiItem.inputs) continue;\n    if (abiItem.inputs.length === 0) continue;\n    if (abiItem.inputs.length !== args.length) continue;\n    const matched = args.every((arg, index) => {\n      const abiParameter = 'inputs' in abiItem && abiItem.inputs[index];\n      if (!abiParameter) return false;\n      return isArgOfType(arg, abiParameter);\n    });\n    if (matched) return abiItem;\n  }\n  return abiItems[0];\n}\nexport function isArgOfType(arg, abiParameter) {\n  const argType = typeof arg;\n  const abiParameterType = abiParameter.type;\n  switch (abiParameterType) {\n    case 'address':\n      return isAddress(arg);\n    case 'bool':\n      return argType === 'boolean';\n    case 'function':\n      return argType === 'string';\n    case 'string':\n      return argType === 'string';\n    default:\n      {\n        if (abiParameterType === 'tuple' && 'components' in abiParameter) return Object.values(abiParameter.components).every((component, index) => {\n          return isArgOfType(Object.values(arg)[index], component);\n        });\n        // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n        // https://regexr.com/6v8hp\n        if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType)) return argType === 'number' || argType === 'bigint';\n        // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n        // https://regexr.com/6va55\n        if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType)) return argType === 'string' || arg instanceof Uint8Array;\n        // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n        // https://regexr.com/6va6i\n        if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n          return Array.isArray(arg) && arg.every(x => isArgOfType(x, {\n            ...abiParameter,\n            // Pop off `[]` or `[M]` from end of type\n            type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, '')\n          }));\n        }\n        return false;\n      }\n  }\n}","map":{"version":3,"names":["isAddress","getAbiItem","abi","args","name","abiItems","filter","x","length","undefined","abiItem","inputs","matched","every","arg","index","abiParameter","isArgOfType","argType","abiParameterType","type","Object","values","components","component","test","Uint8Array","Array","isArray","replace"],"sources":["C:\\Users\\irakl\\OneDrive\\Desktop\\wallet-connect\\node_modules\\viem\\src\\utils\\abi\\getAbiItem.ts"],"sourcesContent":["import type { Abi, AbiParameter, Address, Narrow } from 'abitype'\n\nimport type { GetFunctionArgs, InferItemName } from '../../types/contract.js'\nimport { isAddress } from '../address/isAddress.js'\n\nexport type GetAbiItemParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TItemName extends string = string,\n> = {\n  abi: Narrow<TAbi>\n  name: InferItemName<TAbi, TItemName>\n} & Partial<GetFunctionArgs<TAbi, TItemName>>\n\nexport type GetAbiItemReturnType<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TItemName extends string = string,\n> = Extract<\n  TAbi[number],\n  {\n    name: TItemName\n  }\n>\n\nexport function getAbiItem<\n  TAbi extends Abi | readonly unknown[],\n  TItemName extends string,\n>({\n  abi,\n  args = [],\n  name,\n}: GetAbiItemParameters<TAbi, TItemName>): GetAbiItemReturnType<\n  TAbi,\n  TItemName\n> {\n  const abiItems = (abi as Abi).filter((x) => 'name' in x && x.name === name)\n\n  if (abiItems.length === 0) return undefined as any\n  if (abiItems.length === 1) return abiItems[0] as any\n\n  for (const abiItem of abiItems) {\n    if (!('inputs' in abiItem)) continue\n    if (!args || args.length === 0) {\n      if (!abiItem.inputs || abiItem.inputs.length === 0) return abiItem as any\n      continue\n    }\n    if (!abiItem.inputs) continue\n    if (abiItem.inputs.length === 0) continue\n    if (abiItem.inputs.length !== args.length) continue\n    const matched = (args as readonly unknown[]).every((arg, index) => {\n      const abiParameter = 'inputs' in abiItem && abiItem.inputs![index]\n      if (!abiParameter) return false\n      return isArgOfType(arg, abiParameter as AbiParameter)\n    })\n    if (matched) return abiItem as any\n  }\n  return abiItems[0] as any\n}\n\nexport function isArgOfType(arg: unknown, abiParameter: AbiParameter): boolean {\n  const argType = typeof arg\n  const abiParameterType = abiParameter.type\n  switch (abiParameterType) {\n    case 'address':\n      return isAddress(arg as Address)\n    case 'bool':\n      return argType === 'boolean'\n    case 'function':\n      return argType === 'string'\n    case 'string':\n      return argType === 'string'\n    default: {\n      if (abiParameterType === 'tuple' && 'components' in abiParameter)\n        return Object.values(abiParameter.components).every(\n          (component, index) => {\n            return isArgOfType(\n              Object.values(arg as unknown[] | Record<string, unknown>)[index],\n              component as AbiParameter,\n            )\n          },\n        )\n\n      // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n      // https://regexr.com/6v8hp\n      if (\n        /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(\n          abiParameterType,\n        )\n      )\n        return argType === 'number' || argType === 'bigint'\n\n      // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n      // https://regexr.com/6va55\n      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n        return argType === 'string' || arg instanceof Uint8Array\n\n      // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n      // https://regexr.com/6va6i\n      if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n        return (\n          Array.isArray(arg) &&\n          arg.every((x: unknown) =>\n            isArgOfType(x, {\n              ...abiParameter,\n              // Pop off `[]` or `[M]` from end of type\n              type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n            } as AbiParameter),\n          )\n        )\n      }\n\n      return false\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}