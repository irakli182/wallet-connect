{"ast":null,"code":"import { multicall3Abi } from '../../constants/abis.js';\nimport { AbiDecodingZeroDataError } from '../../errors/abi.js';\nimport { RawContractError } from '../../errors/contract.js';\nimport { decodeFunctionResult } from '../../utils/abi/decodeFunctionResult.js';\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js';\nimport { getChainContractAddress } from '../../utils/chain.js';\nimport { getContractError } from '../../utils/errors/getContractError.js';\nimport { readContract } from './readContract.js';\n/**\n * Similar to [`readContract`](https://viem.sh/docs/contract/readContract.html), but batches up multiple functions on a contract in a single RPC call via the [`multicall3` contract](https://github.com/mds1/multicall).\n *\n * - Docs: https://viem.sh/docs/contract/multicall.html\n *\n * @param client - Client to use\n * @param parameters - {@link MulticallParameters}\n * @returns An array of results with accompanying status. {@link MulticallReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { multicall } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const abi = parseAbi([\n *   'function balanceOf(address) view returns (uint256)',\n *   'function totalSupply() view returns (uint256)',\n * ])\n * const results = await multicall(client, {\n *   contracts: [\n *     {\n *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *       abi,\n *       functionName: 'balanceOf',\n *       args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n *     },\n *     {\n *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *       abi,\n *       functionName: 'totalSupply',\n *     },\n *   ],\n * })\n * // [{ result: 424122n, status: 'success' }, { result: 1000000n, status: 'success' }]\n */\nexport async function multicall(client, args) {\n  const {\n    allowFailure = true,\n    batchSize: batchSize_,\n    blockNumber,\n    blockTag,\n    contracts: contracts_,\n    multicallAddress: multicallAddress_\n  } = args;\n  const batchSize = batchSize_ ?? (typeof client.batch?.multicall === 'object' && client.batch.multicall.batchSize || 1024);\n  // Fix type cast from `Narrow` in type definition.\n  const contracts = contracts_;\n  let multicallAddress = multicallAddress_;\n  if (!multicallAddress) {\n    if (!client.chain) throw new Error('client chain not configured. multicallAddress is required.');\n    multicallAddress = getChainContractAddress({\n      blockNumber,\n      chain: client.chain,\n      contract: 'multicall3'\n    });\n  }\n  const chunkedCalls = [[]];\n  let currentChunk = 0;\n  let currentChunkSize = 0;\n  for (let i = 0; i < contracts.length; i++) {\n    const {\n      abi,\n      address,\n      args,\n      functionName\n    } = contracts[i];\n    try {\n      const callData = encodeFunctionData({\n        abi,\n        args,\n        functionName\n      });\n      currentChunkSize += callData.length;\n      if (batchSize > 0 && currentChunkSize > batchSize) {\n        currentChunk++;\n        currentChunkSize = (callData.length - 2) / 2;\n        chunkedCalls[currentChunk] = [];\n      }\n      chunkedCalls[currentChunk] = [...chunkedCalls[currentChunk], {\n        allowFailure: true,\n        callData,\n        target: address\n      }];\n    } catch (err) {\n      const error = getContractError(err, {\n        abi,\n        address,\n        args,\n        docsPath: '/docs/contract/multicall',\n        functionName\n      });\n      if (!allowFailure) throw error;\n      chunkedCalls[currentChunk] = [...chunkedCalls[currentChunk], {\n        allowFailure: true,\n        callData: '0x',\n        target: address\n      }];\n    }\n  }\n  const results = await Promise.all(chunkedCalls.map(calls => readContract(client, {\n    abi: multicall3Abi,\n    address: multicallAddress,\n    args: [calls],\n    blockNumber,\n    blockTag,\n    functionName: 'aggregate3'\n  })));\n  return results.flat().map(({\n    returnData,\n    success\n  }, i) => {\n    const calls = chunkedCalls.flat();\n    const {\n      callData\n    } = calls[i];\n    const {\n      abi,\n      address,\n      functionName,\n      args\n    } = contracts[i];\n    try {\n      if (callData === '0x') throw new AbiDecodingZeroDataError();\n      if (!success) throw new RawContractError({\n        data: returnData\n      });\n      const result = decodeFunctionResult({\n        abi,\n        args,\n        data: returnData,\n        functionName: functionName\n      });\n      return allowFailure ? {\n        result,\n        status: 'success'\n      } : result;\n    } catch (err) {\n      const error = getContractError(err, {\n        abi,\n        address,\n        args,\n        docsPath: '/docs/contract/multicall',\n        functionName\n      });\n      if (!allowFailure) throw error;\n      return {\n        error,\n        result: undefined,\n        status: 'failure'\n      };\n    }\n  });\n}","map":{"version":3,"names":["multicall3Abi","AbiDecodingZeroDataError","RawContractError","decodeFunctionResult","encodeFunctionData","getChainContractAddress","getContractError","readContract","multicall","client","args","allowFailure","batchSize","batchSize_","blockNumber","blockTag","contracts","contracts_","multicallAddress","multicallAddress_","batch","chain","Error","contract","chunkedCalls","currentChunk","currentChunkSize","i","length","abi","address","functionName","callData","target","err","error","docsPath","results","Promise","all","map","calls","flat","returnData","success","data","result","status","undefined"],"sources":["C:\\Users\\irakl\\OneDrive\\Desktop\\wallet-connect\\node_modules\\viem\\src\\actions\\public\\multicall.ts"],"sourcesContent":["import type { Address, Narrow } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { multicall3Abi } from '../../constants/abis.js'\nimport { AbiDecodingZeroDataError } from '../../errors/abi.js'\nimport type { BaseError } from '../../errors/base.js'\nimport { RawContractError } from '../../errors/contract.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ContractFunctionConfig } from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type {\n  MulticallContracts,\n  MulticallResults,\n} from '../../types/multicall.js'\nimport { decodeFunctionResult } from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeFunctionDataParameters,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport { getChainContractAddress } from '../../utils/chain.js'\nimport { getContractError } from '../../utils/errors/getContractError.js'\n\nimport type { CallParameters } from './call.js'\nimport { readContract } from './readContract.js'\n\nexport type MulticallParameters<\n  TContracts extends ContractFunctionConfig[] = ContractFunctionConfig[],\n  TAllowFailure extends boolean = true,\n> = Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n  allowFailure?: TAllowFailure\n  /** The maximum size (in bytes) for each calldata chunk. Set to `0` to disable the size limit. @default 1_024 */\n  batchSize?: number\n  contracts: Narrow<readonly [...MulticallContracts<TContracts>]>\n  multicallAddress?: Address\n}\n\nexport type MulticallReturnType<\n  TContracts extends ContractFunctionConfig[] = ContractFunctionConfig[],\n  TAllowFailure extends boolean = true,\n> = MulticallResults<TContracts, TAllowFailure>\n\n/**\n * Similar to [`readContract`](https://viem.sh/docs/contract/readContract.html), but batches up multiple functions on a contract in a single RPC call via the [`multicall3` contract](https://github.com/mds1/multicall).\n *\n * - Docs: https://viem.sh/docs/contract/multicall.html\n *\n * @param client - Client to use\n * @param parameters - {@link MulticallParameters}\n * @returns An array of results with accompanying status. {@link MulticallReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { multicall } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const abi = parseAbi([\n *   'function balanceOf(address) view returns (uint256)',\n *   'function totalSupply() view returns (uint256)',\n * ])\n * const results = await multicall(client, {\n *   contracts: [\n *     {\n *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *       abi,\n *       functionName: 'balanceOf',\n *       args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n *     },\n *     {\n *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *       abi,\n *       functionName: 'totalSupply',\n *     },\n *   ],\n * })\n * // [{ result: 424122n, status: 'success' }, { result: 1000000n, status: 'success' }]\n */\nexport async function multicall<\n  TChain extends Chain | undefined,\n  TContracts extends ContractFunctionConfig[],\n  TAllowFailure extends boolean = true,\n>(\n  client: Client<Transport, TChain>,\n  args: MulticallParameters<TContracts, TAllowFailure>,\n): Promise<MulticallReturnType<TContracts, TAllowFailure>> {\n  const {\n    allowFailure = true,\n    batchSize: batchSize_,\n    blockNumber,\n    blockTag,\n    contracts: contracts_,\n    multicallAddress: multicallAddress_,\n  } = args\n\n  const batchSize =\n    batchSize_ ??\n    ((typeof client.batch?.multicall === 'object' &&\n      client.batch.multicall.batchSize) ||\n      1_024)\n\n  // Fix type cast from `Narrow` in type definition.\n  const contracts = contracts_ as readonly [...MulticallContracts<TContracts>]\n\n  let multicallAddress = multicallAddress_\n  if (!multicallAddress) {\n    if (!client.chain)\n      throw new Error(\n        'client chain not configured. multicallAddress is required.',\n      )\n\n    multicallAddress = getChainContractAddress({\n      blockNumber,\n      chain: client.chain,\n      contract: 'multicall3',\n    })\n  }\n\n  type Aggregate3Calls = {\n    allowFailure: boolean\n    callData: Hex\n    target: Address\n  }[]\n\n  const chunkedCalls: Aggregate3Calls[] = [[]]\n  let currentChunk = 0\n  let currentChunkSize = 0\n  for (let i = 0; i < contracts.length; i++) {\n    const { abi, address, args, functionName } = contracts[i]\n    try {\n      const callData = encodeFunctionData({\n        abi,\n        args,\n        functionName,\n      } as unknown as EncodeFunctionDataParameters)\n\n      currentChunkSize += callData.length\n      if (batchSize > 0 && currentChunkSize > batchSize) {\n        currentChunk++\n        currentChunkSize = (callData.length - 2) / 2\n        chunkedCalls[currentChunk] = []\n      }\n\n      chunkedCalls[currentChunk] = [\n        ...chunkedCalls[currentChunk],\n        {\n          allowFailure: true,\n          callData,\n          target: address,\n        },\n      ]\n    } catch (err) {\n      const error = getContractError(err as BaseError, {\n        abi,\n        address,\n        args,\n        docsPath: '/docs/contract/multicall',\n        functionName,\n      })\n      if (!allowFailure) throw error\n      chunkedCalls[currentChunk] = [\n        ...chunkedCalls[currentChunk],\n        {\n          allowFailure: true,\n          callData: '0x' as Hex,\n          target: address,\n        },\n      ]\n    }\n  }\n\n  const results = await Promise.all(\n    chunkedCalls.map((calls) =>\n      readContract(client, {\n        abi: multicall3Abi,\n        address: multicallAddress!,\n        args: [calls],\n        blockNumber,\n        blockTag,\n        functionName: 'aggregate3',\n      }),\n    ),\n  )\n\n  return results.flat().map(({ returnData, success }, i) => {\n    const calls = chunkedCalls.flat()\n    const { callData } = calls[i]\n    const { abi, address, functionName, args } = contracts[i]\n    try {\n      if (callData === '0x') throw new AbiDecodingZeroDataError()\n      if (!success) throw new RawContractError({ data: returnData })\n      const result = decodeFunctionResult({\n        abi,\n        args,\n        data: returnData,\n        functionName: functionName,\n      })\n      return allowFailure ? { result, status: 'success' } : result\n    } catch (err) {\n      const error = getContractError(err as BaseError, {\n        abi,\n        address,\n        args,\n        docsPath: '/docs/contract/multicall',\n        functionName,\n      })\n      if (!allowFailure) throw error\n      return { error, result: undefined, status: 'failure' }\n    }\n  }) as MulticallResults<TContracts, TAllowFailure>\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}